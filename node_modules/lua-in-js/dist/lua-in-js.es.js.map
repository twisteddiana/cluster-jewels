{"version":3,"file":"lua-in-js.es.js","sources":["../src/LuaError.ts","../src/Table.ts","../src/utils.ts","../src/Scope.ts","../src/parser.ts","../src/lib/string.ts","../src/lib/globals.ts","../src/operators.ts","../src/lib/math.ts","../src/lib/table.ts","../src/lib/os.ts","../src/lib/package.ts","../src/index.ts"],"sourcesContent":["export class LuaError extends Error {\r\n    public constructor(message: string) {\r\n        super()\r\n        this.message = message\r\n    }\r\n\r\n    public toString(): string {\r\n        return `LuaError: ${this.message}`\r\n    }\r\n}\r\n","import { hasOwnProperty, LuaType, tostring } from './utils'\r\n\r\ntype MetaMethods =\r\n    // unary op\r\n    | '__unm'\r\n    | '__bnot'\r\n    | '__len'\r\n    // binary op\r\n    | '__add'\r\n    | '__sub'\r\n    | '__mul'\r\n    | '__mod'\r\n    | '__pow'\r\n    | '__div'\r\n    | '__idiv'\r\n    | '__band'\r\n    | '__bor'\r\n    | '__bxor'\r\n    | '__shl'\r\n    | '__shr'\r\n    | '__concat'\r\n    | '__eq'\r\n    | '__lt'\r\n    | '__le'\r\n    // other\r\n    | '__index'\r\n    | '__newindex'\r\n    | '__call'\r\n    | '__pairs'\r\n    | '__ipairs'\r\n    | '__tostring'\r\n\r\nclass Table {\r\n    public numValues: LuaType[] = [undefined]\r\n    public strValues: Record<string, LuaType> = {}\r\n    public keys: string[] = []\r\n    public values: LuaType[] = []\r\n    public metatable: Table | null = null\r\n    public constructor(initialiser?: Record<string, LuaType> | LuaType[] | ((t: Table) => void)) {\r\n        if (initialiser === undefined) return\r\n\r\n        if (typeof initialiser === 'function') {\r\n            initialiser(this)\r\n            return\r\n        }\r\n\r\n        if (Array.isArray(initialiser)) {\r\n            this.insert(...initialiser)\r\n            return\r\n        }\r\n\r\n        for (const key in initialiser) {\r\n            if (hasOwnProperty(initialiser, key)) {\r\n                let value = initialiser[key]\r\n                if (value === null) value = undefined\r\n                this.set(key, value)\r\n            }\r\n        }\r\n    }\r\n\r\n    public get(key: LuaType): LuaType {\r\n        const value = this.rawget(key)\r\n\r\n        if (value === undefined && this.metatable) {\r\n            const mm = this.metatable.get('__index') as Table | Function\r\n\r\n            if (mm instanceof Table) {\r\n                return mm.get(key)\r\n            }\r\n\r\n            if (typeof mm === 'function') {\r\n                const v = mm.call(undefined, this, key)\r\n                return v instanceof Array ? v[0] : v\r\n            }\r\n        }\r\n\r\n        return value\r\n    }\r\n\r\n    public rawget(key: LuaType): LuaType {\r\n        switch (typeof key) {\r\n            case 'string':\r\n                if (hasOwnProperty(this.strValues, key)) {\r\n                    return this.strValues[key]\r\n                }\r\n                break\r\n            case 'number':\r\n                if (key > 0 && key % 1 === 0) {\r\n                    return this.numValues[key]\r\n                }\r\n        }\r\n\r\n        const index = this.keys.indexOf(tostring(key))\r\n        return index === -1 ? undefined : this.values[index]\r\n    }\r\n\r\n    public getMetaMethod(name: MetaMethods): Function {\r\n        return this.metatable && (this.metatable.rawget(name) as Function)\r\n    }\r\n\r\n    public set(key: LuaType, value: LuaType): LuaType {\r\n        const mm = this.metatable && this.metatable.get('__newindex')\r\n        if (mm) {\r\n            const oldValue = this.rawget(key)\r\n\r\n            if (oldValue === undefined) {\r\n                if (mm instanceof Table) {\r\n                    return mm.set(key, value)\r\n                }\r\n                if (typeof mm === 'function') {\r\n                    return mm(this, key, value)\r\n                }\r\n            }\r\n        }\r\n\r\n        this.rawset(key, value)\r\n    }\r\n\r\n    public setFn(key: string): (v: LuaType) => void {\r\n        return v => this.set(key, v)\r\n    }\r\n\r\n    public rawset(key: LuaType, value: LuaType): void {\r\n        switch (typeof key) {\r\n            case 'string':\r\n                this.strValues[key] = value\r\n                return\r\n\r\n            case 'number':\r\n                if (key > 0 && key % 1 === 0) {\r\n                    this.numValues[key] = value\r\n                    return\r\n                }\r\n        }\r\n\r\n        const K = tostring(key)\r\n        const index = this.keys.indexOf(K)\r\n        if (index > -1) {\r\n            this.values[index] = value\r\n            return\r\n        }\r\n\r\n        this.values[this.keys.length] = value\r\n        this.keys.push(K)\r\n    }\r\n\r\n    public insert(...values: LuaType[]): void {\r\n        this.numValues.push(...values)\r\n    }\r\n\r\n    public toObject(): unknown[] | Record<string, unknown> {\r\n        const outputAsArray = Object.keys(this.strValues).length === 0 && this.getn() > 0\r\n        const result: unknown[] | Record<string, unknown> = outputAsArray ? [] : {}\r\n\r\n        for (let i = 1; i < this.numValues.length; i++) {\r\n            const propValue = this.numValues[i]\r\n            const value = propValue instanceof Table ? propValue.toObject() : propValue\r\n\r\n            if (outputAsArray) {\r\n                const res = result as unknown[]\r\n                res[i - 1] = value\r\n            } else {\r\n                const res = result as Record<string, unknown>\r\n                res[String(i - 1)] = value\r\n            }\r\n        }\r\n\r\n        for (const key in this.strValues) {\r\n            if (hasOwnProperty(this.strValues, key)) {\r\n                const propValue = this.strValues[key]\r\n                const value = propValue instanceof Table ? propValue.toObject() : propValue\r\n\r\n                const res = result as Record<string, unknown>\r\n                res[key] = value\r\n            }\r\n        }\r\n\r\n        return result\r\n    }\r\n\r\n    public getn(): number {\r\n        const vals = this.numValues\r\n        const keys: boolean[] = []\r\n\r\n        for (const i in vals) {\r\n            if (hasOwnProperty(vals, i)) {\r\n                keys[i] = true\r\n            }\r\n        }\r\n\r\n        let j = 0\r\n        while (keys[j + 1]) {\r\n            j += 1\r\n        }\r\n\r\n        // Following translated from ltable.c (http://www.lua.org/source/5.3/ltable.c.html)\r\n        if (j > 0 && vals[j] === undefined) {\r\n            /* there is a boundary in the array part: (binary) search for it */\r\n            let i = 0\r\n\r\n            while (j - i > 1) {\r\n                const m = Math.floor((i + j) / 2)\r\n\r\n                if (vals[m] === undefined) {\r\n                    j = m\r\n                } else {\r\n                    i = m\r\n                }\r\n            }\r\n\r\n            return i\r\n        }\r\n\r\n        return j\r\n    }\r\n}\r\n\r\nexport { MetaMethods, Table }\r\n","import { LuaError } from './LuaError'\r\nimport { Table } from './Table'\r\n\r\ntype LuaType = undefined | boolean | number | string | Function | Table // thread | userdata\r\n\r\ninterface Config {\r\n    LUA_PATH?: string\r\n    fileExists?: (path: string) => boolean\r\n    loadFile?: (path: string) => string\r\n    stdin?: string\r\n    stdout?: (data: string) => void\r\n    osExit?: (code: number) => void\r\n}\r\n\r\n/** Pattern to identify a float string value that can validly be converted to a number in Lua */\r\nconst FLOATING_POINT_PATTERN = /^[-+]?[0-9]*\\.?([0-9]+([eE][-+]?[0-9]+)?)?$/\r\n\r\n/** Pattern to identify a hex string value that can validly be converted to a number in Lua */\r\nconst HEXIDECIMAL_CONSTANT_PATTERN = /^(-)?0x([0-9a-fA-F]*)\\.?([0-9a-fA-F]*)$/\r\n\r\nfunction type(v: LuaType): 'string' | 'number' | 'boolean' | 'function' | 'nil' | 'table' {\r\n    const t = typeof v\r\n\r\n    switch (t) {\r\n        case 'undefined':\r\n            return 'nil'\r\n\r\n        case 'number':\r\n        case 'string':\r\n        case 'boolean':\r\n        case 'function':\r\n            return t\r\n\r\n        case 'object':\r\n            if (v instanceof Table) return 'table'\r\n            if (v instanceof Function) return 'function'\r\n    }\r\n}\r\n\r\nfunction tostring(v: LuaType): string {\r\n    if (v instanceof Table) {\r\n        const mm = v.getMetaMethod('__tostring')\r\n        if (mm) return mm(v)[0]\r\n\r\n        return valToStr(v, 'table: 0x')\r\n    }\r\n\r\n    if (v instanceof Function) {\r\n        return valToStr(v, 'function: 0x')\r\n    }\r\n\r\n    return coerceToString(v)\r\n\r\n    function valToStr(v: LuaType, prefix: string): string {\r\n        const s = v.toString()\r\n        if (s.indexOf(prefix) > -1) return s\r\n\r\n        const str = prefix + Math.floor(Math.random() * 0xffffffff).toString(16)\r\n        v.toString = () => str\r\n        return str\r\n    }\r\n}\r\n\r\n/* translate a relative string position: negative means back from end */\r\nfunction posrelat(pos: number, len: number): number {\r\n    if (pos >= 0) return pos\r\n    if (-pos > len) return 0\r\n    return len + pos + 1\r\n}\r\n\r\n/**\r\n * Thows an error with the type of a variable included in the message\r\n * @param {Object} val The value whise type is to be inspected.\r\n * @param {String} errorMessage The error message to throw.\r\n * @throws {LuaError}\r\n */\r\nfunction throwCoerceError(val: LuaType, errorMessage?: string): undefined {\r\n    if (!errorMessage) return undefined\r\n    throw new LuaError(`${errorMessage}`.replace(/%type/gi, type(val)))\r\n}\r\n\r\n/**\r\n * Coerces a value from its current type to a boolean in the same manner as Lua.\r\n * @param {Object} val The value to be converted.\r\n * @returns {Boolean} The converted value.\r\n */\r\nfunction coerceToBoolean(val: LuaType): boolean {\r\n    return !(val === false || val === undefined)\r\n}\r\n\r\n/**\r\n * Coerces a value from its current type to a number in the same manner as Lua.\r\n * @param {Object} val The value to be converted.\r\n * @param {String} [errorMessage] The error message to throw if the conversion fails.\r\n * @returns {Number} The converted value.\r\n */\r\nfunction coerceToNumber(val: LuaType, errorMessage?: string): number {\r\n    if (typeof val === 'number') return val\r\n\r\n    switch (val) {\r\n        case undefined:\r\n            return undefined\r\n        case 'inf':\r\n            return Infinity\r\n        case '-inf':\r\n            return -Infinity\r\n        case 'nan':\r\n            return NaN\r\n    }\r\n\r\n    const V = `${val}`\r\n    if (V.match(FLOATING_POINT_PATTERN)) {\r\n        return parseFloat(V)\r\n    }\r\n\r\n    const match = V.match(HEXIDECIMAL_CONSTANT_PATTERN)\r\n    if (match) {\r\n        const [, sign, exponent, mantissa] = match\r\n        let n = parseInt(exponent, 16) || 0\r\n        if (mantissa) n += parseInt(mantissa, 16) / Math.pow(16, mantissa.length)\r\n        if (sign) n *= -1\r\n        return n\r\n    }\r\n\r\n    if (errorMessage === undefined) return undefined\r\n    throwCoerceError(val, errorMessage)\r\n}\r\n\r\n/**\r\n * Coerces a value from its current type to a string in the same manner as Lua.\r\n * @param {Object} val The value to be converted.\r\n * @param {String} [errorMessage] The error message to throw if the conversion fails.\r\n * @returns {String} The converted value.\r\n */\r\nfunction coerceToString(val: LuaType, errorMessage?: string): string {\r\n    if (typeof val === 'string') return val\r\n\r\n    switch (val) {\r\n        case undefined:\r\n        case null:\r\n            return 'nil'\r\n        case Infinity:\r\n            return 'inf'\r\n        case -Infinity:\r\n            return '-inf'\r\n    }\r\n\r\n    if (typeof val === 'number') {\r\n        return Number.isNaN(val) ? 'nan' : `${val}`\r\n    }\r\n\r\n    if (typeof val === 'boolean') {\r\n        return `${val}`\r\n    }\r\n\r\n    if (errorMessage === undefined) return 'nil'\r\n    throwCoerceError(val, errorMessage)\r\n}\r\n\r\nfunction coerceArg<T>(\r\n    value: LuaType,\r\n    coerceFunc: (val: LuaType, errorMessage?: string) => T,\r\n    typ: 'number' | 'string',\r\n    funcName: string,\r\n    index: number\r\n): T {\r\n    return coerceFunc(value, `bad argument #${index} to '${funcName}' (${typ} expected, got %type)`)\r\n}\r\n\r\nfunction coerceArgToNumber(value: LuaType, funcName: string, index: number): number {\r\n    return coerceArg<number>(value, coerceToNumber, 'number', funcName, index)\r\n}\r\n\r\nfunction coerceArgToString(value: LuaType, funcName: string, index: number): string {\r\n    return coerceArg<string>(value, coerceToString, 'string', funcName, index)\r\n}\r\n\r\nfunction coerceArgToTable(value: LuaType, funcName: string, index: number): Table {\r\n    if (value instanceof Table) {\r\n        return value\r\n    } else {\r\n        const typ = type(value)\r\n        throw new LuaError(`bad argument #${index} to '${funcName}' (table expected, got ${typ})`)\r\n    }\r\n}\r\n\r\nfunction coerceArgToFunction(value: LuaType, funcName: string, index: number): Function {\r\n    if (value instanceof Function) {\r\n        return value\r\n    } else {\r\n        const typ = type(value)\r\n        throw new LuaError(`bad argument #${index} to '${funcName}' (function expected, got ${typ})`)\r\n    }\r\n}\r\n\r\nconst ensureArray = <T>(value: T | T[]): T[] => (value instanceof Array ? value : [value])\r\n\r\nconst hasOwnProperty = (obj: Record<string, unknown> | unknown[], key: string | number): boolean =>\r\n    Object.prototype.hasOwnProperty.call(obj, key)\r\n\r\nexport {\r\n    LuaType,\r\n    Config,\r\n    type,\r\n    tostring,\r\n    posrelat,\r\n    coerceToBoolean,\r\n    coerceToNumber,\r\n    coerceToString,\r\n    coerceArgToNumber,\r\n    coerceArgToString,\r\n    coerceArgToTable,\r\n    coerceArgToFunction,\r\n    ensureArray,\r\n    hasOwnProperty\r\n}\r\n","import { hasOwnProperty, LuaType } from './utils'\r\n\r\nexport class Scope {\r\n    private parent: Scope\r\n    private _varargs: LuaType[]\r\n    private readonly _variables: Record<string, LuaType>\r\n\r\n    public constructor(variables = {}) {\r\n        this._variables = variables\r\n    }\r\n\r\n    public get(key: string): LuaType {\r\n        return this._variables[key]\r\n    }\r\n\r\n    public set(key: string, value: LuaType): void {\r\n        if (hasOwnProperty(this._variables, key) || !this.parent) {\r\n            this.setLocal(key, value)\r\n        } else {\r\n            this.parent.set(key, value)\r\n        }\r\n    }\r\n\r\n    public setLocal(key: string, value: LuaType): void {\r\n        this._variables[key] = value\r\n    }\r\n\r\n    public setVarargs(args: LuaType[]): void {\r\n        this._varargs = args\r\n    }\r\n\r\n    public getVarargs(): LuaType[] {\r\n        return this._varargs || (this.parent && this.parent.getVarargs()) || []\r\n    }\r\n\r\n    public extend(): Scope {\r\n        const innerVars = Object.create(this._variables)\r\n        const scope = new Scope(innerVars)\r\n        scope.parent = this\r\n        return scope\r\n    }\r\n}\r\n","import luaparse from 'luaparse'\r\n\r\ntype Block =\r\n    | luaparse.IfClause\r\n    | luaparse.ElseifClause\r\n    | luaparse.ElseClause\r\n    | luaparse.WhileStatement\r\n    | luaparse.DoStatement\r\n    | luaparse.RepeatStatement\r\n    | luaparse.FunctionDeclaration\r\n    | luaparse.ForNumericStatement\r\n    | luaparse.ForGenericStatement\r\n    | luaparse.Chunk\r\n\r\nconst isBlock = (node: luaparse.Node): node is Block =>\r\n    node.type === 'IfClause' ||\r\n    node.type === 'ElseifClause' ||\r\n    node.type === 'ElseClause' ||\r\n    node.type === 'WhileStatement' ||\r\n    node.type === 'DoStatement' ||\r\n    node.type === 'RepeatStatement' ||\r\n    node.type === 'FunctionDeclaration' ||\r\n    node.type === 'ForNumericStatement' ||\r\n    node.type === 'ForGenericStatement' ||\r\n    node.type === 'Chunk'\r\n\r\nclass MemExpr extends String {\r\n    public base: string | MemExpr\r\n    public property: string | MemExpr\r\n\r\n    public constructor(base: string | MemExpr, property: string | MemExpr) {\r\n        super()\r\n        this.base = base\r\n        this.property = property\r\n    }\r\n\r\n    public get(): string {\r\n        return `__lua.get(${this.base}, ${this.property})`\r\n    }\r\n\r\n    public set(value: string | MemExpr): string {\r\n        return `${this.base}.set(${this.property}, ${value})`\r\n    }\r\n\r\n    public setFn(): string {\r\n        return `${this.base}.setFn(${this.property})`\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.get()\r\n    }\r\n\r\n    public valueOf(): string {\r\n        return this.get()\r\n    }\r\n}\r\n\r\nconst UNI_OP_MAP = {\r\n    not: 'not',\r\n    '-': 'unm',\r\n    '~': 'bnot',\r\n    '#': 'len'\r\n}\r\n\r\nconst BIN_OP_MAP = {\r\n    '+': 'add',\r\n    '-': 'sub',\r\n    '*': 'mul',\r\n    '%': 'mod',\r\n    '^': 'pow',\r\n    '/': 'div',\r\n    '//': 'idiv',\r\n    '&': 'band',\r\n    '|': 'bor',\r\n    '~': 'bxor',\r\n    '<<': 'shl',\r\n    '>>': 'shr',\r\n    '..': 'concat',\r\n    '~=': 'neq',\r\n    '==': 'eq',\r\n    '<': 'lt',\r\n    '<=': 'le',\r\n    '>': 'gt',\r\n    '>=': 'ge'\r\n}\r\n\r\nconst generate = (node: luaparse.Node): string | MemExpr => {\r\n    switch (node.type) {\r\n        case 'LabelStatement': {\r\n            return `case '${node.label.name}': label = undefined`\r\n        }\r\n\r\n        case 'BreakStatement': {\r\n            return 'break'\r\n        }\r\n\r\n        case 'GotoStatement': {\r\n            return `label = '${node.label.name}'; continue`\r\n        }\r\n\r\n        case 'ReturnStatement': {\r\n            const args = parseExpressions(node.arguments)\r\n            return `return ${args}`\r\n        }\r\n\r\n        case 'IfStatement': {\r\n            const clauses = node.clauses.map(clause => generate(clause))\r\n            return clauses.join(' else ')\r\n        }\r\n\r\n        case 'IfClause':\r\n        case 'ElseifClause': {\r\n            const condition = expression(node.condition)\r\n            const body = parseBody(node)\r\n            return `if (__lua.bool(${condition})) {\\n${body}\\n}`\r\n        }\r\n\r\n        case 'ElseClause': {\r\n            const body = parseBody(node)\r\n            return `{\\n${body}\\n}`\r\n        }\r\n\r\n        case 'WhileStatement': {\r\n            const condition = expression(node.condition)\r\n            const body = parseBody(node)\r\n            return `while(${condition}) {\\n${body}\\n}`\r\n        }\r\n\r\n        case 'DoStatement': {\r\n            const body = parseBody(node)\r\n            return `\\n${body}\\n`\r\n        }\r\n\r\n        case 'RepeatStatement': {\r\n            const condition = expression(node.condition)\r\n            const body = parseBody(node)\r\n            return `do {\\n${body}\\n} while (!(${condition}))`\r\n        }\r\n\r\n        case 'LocalStatement': {\r\n            return parseAssignments(node)\r\n        }\r\n\r\n        case 'AssignmentStatement': {\r\n            return parseAssignments(node)\r\n        }\r\n\r\n        case 'CallStatement': {\r\n            return generate(node.expression)\r\n        }\r\n\r\n        case 'FunctionDeclaration': {\r\n            const getFuncDef = (params: string[]): string => {\r\n                const paramStr = params.join(';\\n')\r\n                const body = parseBody(node, paramStr)\r\n                const argsStr = params.length === 0 ? '' : '...args'\r\n                const returnStr =\r\n                    node.body.findIndex(node => node.type === 'ReturnStatement') === -1 ? '\\nreturn []' : ''\r\n                return `(${argsStr}) => {\\n${body}${returnStr}\\n}`\r\n            }\r\n\r\n            const params = node.parameters.map(param => {\r\n                if (param.type === 'VarargLiteral') {\r\n                    return `$${nodeToScope.get(param)}.setVarargs(args)`\r\n                }\r\n                return `$${nodeToScope.get(param)}.setLocal('${param.name}', args.shift())`\r\n            })\r\n\r\n            // anonymous function\r\n            if (node.identifier === null) return getFuncDef(params)\r\n\r\n            if (node.identifier.type === 'Identifier') {\r\n                const scope = nodeToScope.get(node.identifier)\r\n                const setStr = node.isLocal ? 'setLocal' : 'set'\r\n                return `$${scope}.${setStr}('${node.identifier.name}', ${getFuncDef(params)})`\r\n            }\r\n\r\n            const identifier = generate(node.identifier) as MemExpr\r\n            if (node.identifier.indexer === ':') {\r\n                params.unshift(`$${nodeToScope.get(node)}.setLocal('self', args.shift())`)\r\n            }\r\n            return identifier.set(getFuncDef(params))\r\n        }\r\n\r\n        case 'ForNumericStatement': {\r\n            const varName = node.variable.name\r\n            const start = expression(node.start)\r\n            const end = expression(node.end)\r\n            const step = node.step === null ? 1 : expression(node.step)\r\n            const init = `let ${varName} = ${start}, end = ${end}, step = ${step}`\r\n            const cond = `step > 0 ? ${varName} <= end : ${varName} >= end`\r\n            const after = `${varName} += step`\r\n            const varInit = `$${nodeToScope.get(node.variable)}.setLocal('${varName}', ${varName});`\r\n            const body = parseBody(node, varInit)\r\n\r\n            return `for (${init}; ${cond}; ${after}) {\\n${body}\\n}`\r\n        }\r\n\r\n        case 'ForGenericStatement': {\r\n            const iterators = parseExpressions(node.iterators)\r\n\r\n            const variables = node.variables\r\n                .map((variable, index) => {\r\n                    return `$${nodeToScope.get(variable)}.setLocal('${variable.name}', res[${index}])`\r\n                })\r\n                .join(';\\n')\r\n\r\n            const body = parseBody(node, variables)\r\n\r\n            return `for (let [iterator, table, next] = ${iterators}, res = __lua.call(iterator, table, next); res[0] !== undefined; res = __lua.call(iterator, table, res[0])) {\\n${body}\\n}`\r\n        }\r\n\r\n        case 'Chunk': {\r\n            const body = parseBody(node)\r\n            return `'use strict'\\nconst $0 = __lua.globalScope\\nlet vars\\nlet vals\\nlet label\\n\\n${body}`\r\n        }\r\n\r\n        case 'Identifier': {\r\n            return `$${nodeToScope.get(node)}.get('${node.name}')`\r\n        }\r\n\r\n        case 'StringLiteral': {\r\n            const S = node.value\r\n                .replace(/([^\\\\])?\\\\(\\d{1,3})/g, (_, pre, dec) => `${pre || ''}${String.fromCharCode(dec)}`)\r\n                .replace(/\\\\/g, '\\\\\\\\')\r\n\r\n            return `\\`${S}\\``\r\n        }\r\n\r\n        case 'NumericLiteral': {\r\n            return node.value.toString()\r\n        }\r\n\r\n        case 'BooleanLiteral': {\r\n            return node.value ? 'true' : 'false'\r\n        }\r\n\r\n        case 'NilLiteral': {\r\n            return 'undefined'\r\n        }\r\n\r\n        case 'VarargLiteral': {\r\n            return `$${nodeToScope.get(node)}.getVarargs()`\r\n        }\r\n\r\n        // inside TableConstructorExpression\r\n        // case 'TableKey': {}\r\n        // case 'TableKeyString': {}\r\n        // case 'TableValue': {}\r\n\r\n        case 'TableConstructorExpression': {\r\n            if (node.fields.length === 0) return 'new __lua.Table()'\r\n\r\n            const fields = node.fields\r\n                .map((field, index, arr) => {\r\n                    if (field.type === 'TableKey') {\r\n                        return `t.rawset(${generate(field.key)}, ${expression(field.value)})`\r\n                    }\r\n\r\n                    if (field.type === 'TableKeyString') {\r\n                        return `t.rawset('${field.key.name}', ${expression(field.value)})`\r\n                    }\r\n\r\n                    if (field.type === 'TableValue') {\r\n                        if (index === arr.length - 1 && ExpressionReturnsArray(field.value)) {\r\n                            return `t.insert(...${generate(field.value)})`\r\n                        }\r\n                        return `t.insert(${expression(field.value)})`\r\n                    }\r\n                })\r\n                .join(';\\n')\r\n\r\n            return `new __lua.Table(t => {\\n${fields}\\n})`\r\n        }\r\n\r\n        case 'UnaryExpression': {\r\n            const operator = UNI_OP_MAP[node.operator]\r\n            const argument = expression(node.argument)\r\n\r\n            if (!operator) {\r\n                throw new Error(`Unhandled unary operator: ${node.operator}`)\r\n            }\r\n\r\n            return `__lua.${operator}(${argument})`\r\n        }\r\n\r\n        case 'BinaryExpression': {\r\n            const left = expression(node.left)\r\n            const right = expression(node.right)\r\n            const operator = BIN_OP_MAP[node.operator]\r\n\r\n            if (!operator) {\r\n                throw new Error(`Unhandled binary operator: ${node.operator}`)\r\n            }\r\n\r\n            return `__lua.${operator}(${left}, ${right})`\r\n        }\r\n\r\n        case 'LogicalExpression': {\r\n            const left = expression(node.left)\r\n            const right = expression(node.right)\r\n            const operator = node.operator\r\n\r\n            if (operator === 'and') {\r\n                return `(!__lua.bool(${left})?${left}:${right})`\r\n            }\r\n            if (operator === 'or') {\r\n                return `(__lua.bool(${left})?${left}:${right})`\r\n            }\r\n            throw new Error(`Unhandled logical operator: ${node.operator}`)\r\n        }\r\n        case 'MemberExpression': {\r\n            const base = expression(node.base)\r\n            return new MemExpr(base, `'${node.identifier.name}'`)\r\n        }\r\n\r\n        case 'IndexExpression': {\r\n            const base = expression(node.base)\r\n            const index = expression(node.index)\r\n            return new MemExpr(base, index)\r\n        }\r\n\r\n        case 'CallExpression':\r\n        case 'TableCallExpression':\r\n        case 'StringCallExpression': {\r\n            const functionName = expression(node.base)\r\n            const args =\r\n                node.type === 'CallExpression'\r\n                    ? parseExpressionList(node.arguments).join(', ')\r\n                    : expression(node.type === 'TableCallExpression' ? node.arguments : node.argument)\r\n\r\n            if (functionName instanceof MemExpr && node.base.type === 'MemberExpression' && node.base.indexer === ':') {\r\n                return `__lua.call(${functionName}, ${functionName.base}, ${args})`\r\n            }\r\n\r\n            return `__lua.call(${functionName}, ${args})`\r\n        }\r\n\r\n        default:\r\n            throw new Error(`No generator found for: ${node.type}`)\r\n    }\r\n}\r\n\r\nconst parseBody = (node: Block, header = ''): string => {\r\n    const scope = nodeToScope.get(node)\r\n    const scopeDef = scope === undefined ? '' : `const $${scope} = $${scopeToParentScope.get(scope)}.extend();`\r\n\r\n    const body = node.body.map(statement => generate(statement)).join(';\\n')\r\n\r\n    const goto = nodeToGoto.get(node)\r\n    if (goto === undefined) return `${scopeDef}\\n${header}\\n${body}`\r\n\r\n    const gotoHeader = `L${goto}: do { switch(label) { case undefined:`\r\n    const gotoParent = gotoToParentGoto.get(goto)\r\n    const def = gotoParent === undefined ? '' : `break; default: continue L${gotoParent}\\n`\r\n    const footer = `${def}} } while (label)`\r\n\r\n    return `${scopeDef}\\n${gotoHeader}\\n${header}\\n${body}\\n${footer}`\r\n}\r\n\r\nconst expression = (node: luaparse.Expression): string | MemExpr => {\r\n    const v = generate(node)\r\n    if (ExpressionReturnsArray(node)) return `${v}[0]`\r\n    return v\r\n}\r\n\r\nconst parseExpressions = (expressions: luaparse.Expression[]): string | MemExpr => {\r\n    // return the `array` directly instead of `[...array]`\r\n    if (expressions.length === 1 && ExpressionReturnsArray(expressions[0])) {\r\n        return generate(expressions[0])\r\n    }\r\n\r\n    return `[${parseExpressionList(expressions).join(', ')}]`\r\n}\r\n\r\nconst parseExpressionList = (expressions: luaparse.Expression[]): (string | MemExpr)[] => {\r\n    return expressions.map((node, index, arr) => {\r\n        const value = generate(node)\r\n        if (ExpressionReturnsArray(node)) {\r\n            return index === arr.length - 1 ? `...${value}` : `${value}[0]`\r\n        }\r\n        return value\r\n    })\r\n}\r\n\r\nconst parseAssignments = (node: luaparse.LocalStatement | luaparse.AssignmentStatement): string => {\r\n    const lines: (string | MemExpr)[] = []\r\n    const valFns: string[] = []\r\n\r\n    const useTempVar = node.variables.length > 1 && node.init.length > 0 && !node.init.every(isLiteral)\r\n\r\n    for (let i = 0; i < node.variables.length; i++) {\r\n        const K = node.variables[i]\r\n        const V = node.init[i]\r\n\r\n        const initStr =\r\n            // eslint-disable-next-line no-nested-ternary\r\n            useTempVar ? `vars[${i}]` : V === undefined ? 'undefined' : expression(V)\r\n\r\n        if (K.type === 'Identifier') {\r\n            const setStr = node.type === 'LocalStatement' ? 'setLocal' : 'set'\r\n            lines.push(`$${nodeToScope.get(K)}.${setStr}('${K.name}', ${initStr})`)\r\n        } else {\r\n            const name = generate(K) as MemExpr\r\n\r\n            if (useTempVar) {\r\n                lines.push(`vals[${valFns.length}](${initStr})`)\r\n                valFns.push(name.setFn())\r\n            } else {\r\n                lines.push(name.set(initStr))\r\n            }\r\n        }\r\n    }\r\n\r\n    // push remaining CallExpressions\r\n    for (let i = node.variables.length; i < node.init.length; i++) {\r\n        const init = node.init[i]\r\n        if (isCallExpression(init)) {\r\n            lines.push(generate(init))\r\n        }\r\n    }\r\n\r\n    if (useTempVar) {\r\n        lines.unshift(`vars = ${parseExpressions(node.init)}`)\r\n        if (valFns.length > 0) {\r\n            lines.unshift(`vals = [${valFns.join(', ')}]`)\r\n        }\r\n    }\r\n\r\n    return lines.join(';\\n')\r\n}\r\n\r\nconst isCallExpression = (\r\n    node: luaparse.Expression\r\n): node is luaparse.CallExpression | luaparse.StringCallExpression | luaparse.TableCallExpression => {\r\n    return node.type === 'CallExpression' || node.type === 'StringCallExpression' || node.type === 'TableCallExpression'\r\n}\r\n\r\nconst ExpressionReturnsArray = (node: luaparse.Expression): boolean => {\r\n    return isCallExpression(node) || node.type === 'VarargLiteral'\r\n}\r\n\r\nconst isLiteral = (node: luaparse.Expression): boolean => {\r\n    return (\r\n        node.type === 'StringLiteral' ||\r\n        node.type === 'NumericLiteral' ||\r\n        node.type === 'BooleanLiteral' ||\r\n        node.type === 'NilLiteral' ||\r\n        node.type === 'TableConstructorExpression'\r\n    )\r\n}\r\n\r\nconst checkGoto = (ast: luaparse.Chunk): void => {\r\n    const gotoInfo: {\r\n        type: 'local' | 'label' | 'goto'\r\n        name: string\r\n        scope: number\r\n        last?: boolean\r\n    }[] = []\r\n\r\n    let gotoScope = 0\r\n    const gotoScopeMap = new Map<number, number>()\r\n    const getNextGotoScope = (() => {\r\n        let id = 0\r\n        return () => {\r\n            id += 1\r\n            return id\r\n        }\r\n    })()\r\n\r\n    const check = (node: luaparse.Node): void => {\r\n        if (isBlock(node)) {\r\n            createGotoScope()\r\n\r\n            for (let i = 0; i < node.body.length; i++) {\r\n                const n = node.body[i]\r\n                switch (n.type) {\r\n                    case 'LocalStatement': {\r\n                        gotoInfo.push({\r\n                            type: 'local',\r\n                            name: n.variables[0].name,\r\n                            scope: gotoScope\r\n                        })\r\n                        break\r\n                    }\r\n                    case 'LabelStatement': {\r\n                        if (\r\n                            gotoInfo.find(\r\n                                node => node.type === 'label' && node.name === n.label.name && node.scope === gotoScope\r\n                            )\r\n                        ) {\r\n                            throw new Error(`label '${n.label.name}' already defined`)\r\n                        }\r\n\r\n                        gotoInfo.push({\r\n                            type: 'label',\r\n                            name: n.label.name,\r\n                            scope: gotoScope,\r\n                            last:\r\n                                node.type !== 'RepeatStatement' &&\r\n                                node.body.slice(i).every(n => n.type === 'LabelStatement')\r\n                        })\r\n                        break\r\n                    }\r\n                    case 'GotoStatement': {\r\n                        gotoInfo.push({\r\n                            type: 'goto',\r\n                            name: n.label.name,\r\n                            scope: gotoScope\r\n                        })\r\n                        break\r\n                    }\r\n                    case 'IfStatement': {\r\n                        n.clauses.forEach(n => check(n))\r\n                        break\r\n                    }\r\n                    default: {\r\n                        check(n)\r\n                    }\r\n                }\r\n            }\r\n\r\n            destroyGotoScope()\r\n        }\r\n    }\r\n    check(ast)\r\n\r\n    function createGotoScope(): void {\r\n        const parent = gotoScope\r\n        gotoScope = getNextGotoScope()\r\n        gotoScopeMap.set(gotoScope, parent)\r\n    }\r\n    function destroyGotoScope(): void {\r\n        gotoScope = gotoScopeMap.get(gotoScope)\r\n    }\r\n\r\n    for (let i = 0; i < gotoInfo.length; i++) {\r\n        const goto = gotoInfo[i]\r\n\r\n        if (goto.type === 'goto') {\r\n            const label = gotoInfo\r\n                .filter(node => node.type === 'label' && node.name === goto.name && node.scope <= goto.scope)\r\n                .sort((a, b) => Math.abs(goto.scope - a.scope) - Math.abs(goto.scope - b.scope))[0]\r\n\r\n            if (!label) {\r\n                throw new Error(`no visible label '${goto.name}' for <goto>`)\r\n            }\r\n\r\n            const labelI = gotoInfo.findIndex(n => n === label)\r\n\r\n            if (labelI > i) {\r\n                const locals = gotoInfo\r\n                    .slice(i, labelI)\r\n                    .filter(node => node.type === 'local' && node.scope === label.scope)\r\n\r\n                if (!label.last && locals.length > 0) {\r\n                    throw new Error(`<goto ${goto.name}> jumps into the scope of local '${locals[0].name}'`)\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst visitNode = (\r\n    node: luaparse.Node,\r\n    visitProp: (node: luaparse.Node, prevScope: number, prevGoto: number) => void,\r\n    nextScope: number,\r\n    isNewScope: boolean,\r\n    nextGoto: number\r\n): void => {\r\n    const VP = (node: luaparse.Node | luaparse.Node[], partOfBlock = true): void => {\r\n        if (!node) return\r\n\r\n        const S = partOfBlock === false && isNewScope ? scopeToParentScope.get(nextScope) : nextScope\r\n        if (Array.isArray(node)) {\r\n            node.forEach(n => visitProp(n, S, nextGoto))\r\n        } else {\r\n            visitProp(node, S, nextGoto)\r\n        }\r\n    }\r\n\r\n    switch (node.type) {\r\n        case 'LocalStatement':\r\n        case 'AssignmentStatement':\r\n            VP(node.variables)\r\n            VP(node.init)\r\n            break\r\n        case 'UnaryExpression':\r\n            VP(node.argument)\r\n            break\r\n        case 'BinaryExpression':\r\n        case 'LogicalExpression':\r\n            VP(node.left)\r\n            VP(node.right)\r\n            break\r\n        case 'FunctionDeclaration':\r\n            VP(node.identifier, false)\r\n            VP(node.parameters)\r\n            VP(node.body)\r\n            break\r\n        case 'ForGenericStatement':\r\n            VP(node.variables)\r\n            VP(node.iterators, false)\r\n            VP(node.body)\r\n            break\r\n        case 'IfClause':\r\n        case 'ElseifClause':\r\n        case 'WhileStatement':\r\n        case 'RepeatStatement':\r\n            VP(node.condition, false)\r\n        /* fall through */\r\n        case 'Chunk':\r\n        case 'ElseClause':\r\n        case 'DoStatement':\r\n            VP(node.body)\r\n            // VK(node.globals)\r\n            // VK(node.comments)\r\n            break\r\n        case 'ForNumericStatement':\r\n            VP(node.variable)\r\n            VP(node.start, false)\r\n            VP(node.end, false)\r\n            VP(node.step, false)\r\n            VP(node.body)\r\n            break\r\n        case 'ReturnStatement':\r\n            VP(node.arguments)\r\n            break\r\n        case 'IfStatement':\r\n            VP(node.clauses)\r\n            break\r\n        case 'MemberExpression':\r\n            VP(node.base)\r\n            VP(node.identifier)\r\n            break\r\n        case 'IndexExpression':\r\n            VP(node.base)\r\n            VP(node.index)\r\n            break\r\n        case 'LabelStatement':\r\n            VP(node.label)\r\n            break\r\n        case 'CallStatement':\r\n            VP(node.expression)\r\n            break\r\n        case 'GotoStatement':\r\n            VP(node.label)\r\n            break\r\n        case 'TableConstructorExpression':\r\n            VP(node.fields)\r\n            break\r\n        case 'TableKey':\r\n        case 'TableKeyString':\r\n            VP(node.key)\r\n        /* fall through */\r\n        case 'TableValue':\r\n            VP(node.value)\r\n            break\r\n        case 'CallExpression':\r\n            VP(node.base)\r\n            VP(node.arguments)\r\n            break\r\n        case 'TableCallExpression':\r\n            VP(node.base)\r\n            VP(node.arguments)\r\n            break\r\n        case 'StringCallExpression':\r\n            VP(node.base)\r\n            VP(node.argument)\r\n        //     break\r\n        // case 'Identifier':\r\n        // case 'NumericLiteral':\r\n        // case 'BooleanLiteral':\r\n        // case 'StringLiteral':\r\n        // case 'NilLiteral':\r\n        // case 'VarargLiteral':\r\n        // case 'BreakStatement':\r\n        // case 'Comment':\r\n        //     break\r\n        // default:\r\n        //     throw new Error(`Unhandled ${node.type}`)\r\n    }\r\n}\r\n\r\nconst scopeToParentScope = new Map<number, number>()\r\nconst nodeToScope = new Map<luaparse.Node, number>()\r\n\r\nconst gotoToParentGoto = new Map<number, number>()\r\nconst nodeToGoto = new Map<luaparse.Node, number>()\r\n\r\nconst setExtraInfo = (ast: luaparse.Chunk): void => {\r\n    let scopeID = 0\r\n    let gotoID = 0\r\n\r\n    const visitProp = (node: luaparse.Node, prevScope: number, prevGoto: number): void => {\r\n        let nextScope = prevScope\r\n        let nextGoto = prevGoto\r\n\r\n        if (isBlock(node)) {\r\n            // set scope info\r\n            if (\r\n                node.body.findIndex(\r\n                    n => n.type === 'LocalStatement' || (n.type === 'FunctionDeclaration' && n.isLocal)\r\n                ) !== -1 ||\r\n                (node.type === 'FunctionDeclaration' &&\r\n                    (node.parameters.length > 0 || (node.identifier && node.identifier.type === 'MemberExpression'))) ||\r\n                node.type === 'ForNumericStatement' ||\r\n                node.type === 'ForGenericStatement'\r\n            ) {\r\n                scopeID += 1\r\n                nextScope = scopeID\r\n\r\n                nodeToScope.set(node, scopeID)\r\n                scopeToParentScope.set(scopeID, prevScope)\r\n            }\r\n\r\n            // set goto info\r\n            if (node.body.findIndex(s => s.type === 'LabelStatement' || s.type === 'GotoStatement') !== -1) {\r\n                nextGoto = gotoID\r\n\r\n                nodeToGoto.set(node, gotoID)\r\n                if (node.type !== 'Chunk' && node.type !== 'FunctionDeclaration') {\r\n                    gotoToParentGoto.set(gotoID, prevGoto)\r\n                }\r\n\r\n                gotoID += 1\r\n            }\r\n        }\r\n\r\n        // set scope info\r\n        else if (node.type === 'Identifier' || node.type === 'VarargLiteral') {\r\n            nodeToScope.set(node, prevScope)\r\n        }\r\n\r\n        visitNode(node, visitProp, nextScope, prevScope !== nextScope, nextGoto)\r\n    }\r\n\r\n    visitProp(ast, scopeID, gotoID)\r\n}\r\n\r\nconst parse = (data: string): string => {\r\n    const ast = luaparse.parse(data.replace(/^#.*/, ''), {\r\n        scope: false,\r\n        comments: false,\r\n        luaVersion: '5.3'\r\n    })\r\n    checkGoto(ast)\r\n    setExtraInfo(ast)\r\n    return generate(ast).toString()\r\n}\r\n\r\nexport { parse }\r\n","import printj from 'printj'\r\nimport { Table } from '../Table'\r\nimport { LuaError } from '../LuaError'\r\nimport { tostring, posrelat, coerceArgToNumber, coerceArgToString, hasOwnProperty, LuaType } from '../utils'\r\n\r\nconst ROSETTA_STONE: Record<string, string> = {\r\n    '([^a-zA-Z0-9%(])-': '$1*?',\r\n    '([^%])-([^a-zA-Z0-9?])': '$1*?$2',\r\n    '([^%])\\\\.': '$1[\\\\s\\\\S]',\r\n    '(.)-$': '$1*?',\r\n    '%a': '[a-zA-Z]',\r\n    '%A': '[^a-zA-Z]',\r\n    '%c': '[\\x00-\\x1f]',\r\n    '%C': '[^\\x00-\\x1f]',\r\n    '%d': '\\\\d',\r\n    '%D': '[^d]',\r\n    '%l': '[a-z]',\r\n    '%L': '[^a-z]',\r\n    '%p': '[.,\"\\'?!;:#$%&()*+-/<>=@\\\\[\\\\]\\\\\\\\^_{}|~]',\r\n    '%P': '[^.,\"\\'?!;:#$%&()*+-/<>=@\\\\[\\\\]\\\\\\\\^_{}|~]',\r\n    '%s': '[ \\\\t\\\\n\\\\f\\\\v\\\\r]',\r\n    '%S': '[^ \\t\\n\\f\\v\\r]',\r\n    '%u': '[A-Z]',\r\n    '%U': '[^A-Z]',\r\n    '%w': '[a-zA-Z0-9]',\r\n    '%W': '[^a-zA-Z0-9]',\r\n    '%x': '[a-fA-F0-9]',\r\n    '%X': '[^a-fA-F0-9]',\r\n    '%([^a-zA-Z])': '\\\\$1'\r\n}\r\n\r\nfunction translatePattern(pattern: string): string {\r\n    // TODO Add support for balanced character matching (not sure this is easily achieveable).\r\n\r\n    // Replace single backslash with double backslashes\r\n    let tPattern = pattern.replace(/\\\\/g, '\\\\\\\\')\r\n\r\n    for (const i in ROSETTA_STONE) {\r\n        if (hasOwnProperty(ROSETTA_STONE, i)) {\r\n            tPattern = tPattern.replace(new RegExp(i, 'g'), ROSETTA_STONE[i])\r\n        }\r\n    }\r\n\r\n    let nestingLevel = 0\r\n\r\n    for (let i = 0, l = tPattern.length; i < l; i++) {\r\n        if (i && tPattern.substr(i - 1, 1) === '\\\\') {\r\n            continue\r\n        }\r\n\r\n        // Remove nested square brackets caused by substitutions\r\n        const character = tPattern.substr(i, 1)\r\n\r\n        if (character === '[' || character === ']') {\r\n            if (character === ']') {\r\n                nestingLevel -= 1\r\n            }\r\n\r\n            if (nestingLevel > 0) {\r\n                tPattern = tPattern.substr(0, i) + tPattern.substr(i + 1)\r\n                i -= 1\r\n                l -= 1\r\n            }\r\n\r\n            if (character === '[') {\r\n                nestingLevel += 1\r\n            }\r\n        }\r\n    }\r\n\r\n    return tPattern\r\n}\r\n\r\n/**\r\n * Returns the internal numeric codes of the characters s[i], s[i+1], ..., s[j].\r\n * The default value for i is 1; the default value for j is i.\r\n * These indices are corrected following the same rules of function string.sub.\r\n *\r\n * Numeric codes are not necessarily portable across platforms.\r\n */\r\nfunction byte(s: LuaType, i: LuaType, j: LuaType): number[] {\r\n    const S = coerceArgToString(s, 'byte', 1)\r\n    const I = i === undefined ? 1 : coerceArgToNumber(i, 'byte', 2)\r\n    const J = j === undefined ? I : coerceArgToNumber(j, 'byte', 3)\r\n\r\n    return S.substring(I - 1, J)\r\n        .split('')\r\n        .map(c => c.charCodeAt(0))\r\n}\r\n\r\n/**\r\n * Receives zero or more integers. Returns a string with length equal to the number of arguments,\r\n * in which each character has the internal numeric code equal to its corresponding argument.\r\n *\r\n * Numeric codes are not necessarily portable across platforms.\r\n */\r\nfunction char(...bytes: LuaType[]): string {\r\n    return bytes\r\n        .map((b, i) => {\r\n            const B = coerceArgToNumber(b, 'char', i)\r\n            return String.fromCharCode(B)\r\n        })\r\n        .join('')\r\n}\r\n\r\n/**\r\n * Looks for the first match of pattern (see §6.4.1) in the string s. If it finds a match, then find returns\r\n * the indices of s where this occurrence starts and ends; otherwise, it returns nil.\r\n * A third, optional numeric argument init specifies where to start the search; its default value is 1 and can be negative.\r\n * A value of true as a fourth, optional argument plain turns off the pattern matching facilities,\r\n * so the function does a plain \"find substring\" operation, with no characters in pattern being considered magic.\r\n * Note that if plain is given, then init must be given as well.\r\n *\r\n * If the pattern has captures, then in a successful match the captured values are also returned, after the two indices.\r\n */\r\nfunction find(s: LuaType, pattern: LuaType, init: LuaType, plain: LuaType): (number | string)[] {\r\n    const S = coerceArgToString(s, 'find', 1)\r\n    const P = coerceArgToString(pattern, 'find', 2)\r\n    const INIT = init === undefined ? 1 : coerceArgToNumber(init, 'find', 3)\r\n    const PLAIN = plain === undefined ? false : coerceArgToNumber(plain, 'find', 4)\r\n\r\n    // Regex\r\n    if (!PLAIN) {\r\n        const regex = new RegExp(translatePattern(P))\r\n        const index = S.substr(INIT - 1).search(regex)\r\n\r\n        if (index < 0) return\r\n\r\n        const match = S.substr(INIT - 1).match(regex)\r\n        const result = [index + INIT, index + INIT + match[0].length - 1]\r\n\r\n        match.shift()\r\n        return [...result, ...match]\r\n    }\r\n\r\n    // Plain\r\n    const index = S.indexOf(P, INIT - 1)\r\n    return index === -1 ? undefined : [index + 1, index + P.length]\r\n}\r\n\r\nfunction format(formatstring: string, ...args: LuaType[]): string {\r\n    // Pattern with all constraints:\r\n    // /%%|%([-+ #0]{0,5})?(\\d{0,2})?(?:\\.(\\d{0,2}))?([AEGXacdefgioqsux])/g\r\n    const PATTERN = /%%|%([-+ #0]*)?(\\d*)?(?:\\.(\\d*))?(.)/g\r\n\r\n    let i = -1\r\n    return formatstring.replace(PATTERN, (format, flags, width, precision, modifier) => {\r\n        if (format === '%%') return '%'\r\n        if (!modifier.match(/[AEGXacdefgioqsux]/)) {\r\n            throw new LuaError(`invalid option '%${format}' to 'format'`)\r\n        }\r\n        if (flags && flags.length > 5) {\r\n            throw new LuaError(`invalid format (repeated flags)`)\r\n        }\r\n        if (width && width.length > 2) {\r\n            throw new LuaError(`invalid format (width too long)`)\r\n        }\r\n        if (precision && precision.length > 2) {\r\n            throw new LuaError(`invalid format (precision too long)`)\r\n        }\r\n\r\n        i += 1\r\n        const arg = args[i]\r\n        if (arg === undefined) {\r\n            throw new LuaError(`bad argument #${i} to 'format' (no value)`)\r\n        }\r\n        if (/A|a|E|e|f|G|g/.test(modifier)) {\r\n            return printj.sprintf(format, coerceArgToNumber(arg, 'format', i))\r\n        }\r\n        if (/c|d|i|o|u|X|x/.test(modifier)) {\r\n            return printj.sprintf(format, coerceArgToNumber(arg, 'format', i))\r\n        }\r\n\r\n        if (modifier === 'q') {\r\n            return `\"${(arg as string).replace(/([\\n\"])/g, '\\\\$1')}\"`\r\n        }\r\n        if (modifier === 's') {\r\n            return printj.sprintf(format, tostring(arg))\r\n        }\r\n        return printj.sprintf(format, arg)\r\n    })\r\n}\r\n\r\n/**\r\n * Returns an iterator function that, each time it is called, returns the next captures from pattern (see §6.4.1)\r\n * over the string s. If pattern specifies no captures, then the whole match is produced in each call.\r\n */\r\nfunction gmatch(s: LuaType, pattern: LuaType): () => string[] {\r\n    const S = coerceArgToString(s, 'gmatch', 1)\r\n    const P = translatePattern(coerceArgToString(pattern, 'gmatch', 2))\r\n\r\n    const reg = new RegExp(P, 'g')\r\n    const matches = S.match(reg)\r\n\r\n    return () => {\r\n        const match = matches.shift()\r\n        if (match === undefined) return []\r\n\r\n        const groups = new RegExp(P).exec(match)\r\n        groups.shift()\r\n        return groups.length ? groups : [match]\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a copy of s in which all (or the first n, if given) occurrences of the pattern (see §6.4.1)\r\n * have been replaced by a replacement string specified by repl, which can be a string, a table, or a function.\r\n * gsub also returns, as its second value, the total number of matches that occurred.\r\n * The name gsub comes from Global SUBstitution.\r\n *\r\n * If repl is a string, then its value is used for replacement. The character % works as an escape character:\r\n * any sequence in repl of the form %d, with d between 1 and 9, stands for the value of the d-th captured substring.\r\n * The sequence %0 stands for the whole match. The sequence %% stands for a single %.\r\n *\r\n * If repl is a table, then the table is queried for every match, using the first capture as the key.\r\n *\r\n * If repl is a function, then this function is called every time a match occurs,\r\n * with all captured substrings passed as arguments, in order.\r\n *\r\n * In any case, if the pattern specifies no captures, then it behaves as if the whole pattern was inside a capture.\r\n *\r\n * If the value returned by the table query or by the function call is a string or a number,\r\n * then it is used as the replacement string; otherwise, if it is false or nil, then there is no replacement\r\n * (that is, the original match is kept in the string).\r\n */\r\nfunction gsub(s: LuaType, pattern: LuaType, repl: LuaType, n?: LuaType): string {\r\n    let S = coerceArgToString(s, 'gsub', 1)\r\n    const N = n === undefined ? Infinity : coerceArgToNumber(n, 'gsub', 3)\r\n    const P = translatePattern(coerceArgToString(pattern, 'gsub', 2))\r\n\r\n    const REPL = ((): ((strs: string[]) => string) => {\r\n        if (typeof repl === 'function')\r\n            return strs => {\r\n                const ret = repl(strs[0])[0]\r\n                return ret === undefined ? strs[0] : ret\r\n            }\r\n\r\n        if (repl instanceof Table) return strs => repl.get(strs[0]).toString()\r\n\r\n        return strs => `${repl}`.replace(/%([0-9])/g, (_, i) => strs[i])\r\n    })()\r\n\r\n    let result = ''\r\n    let count = 0\r\n    let match\r\n    let lastMatch\r\n    while (count < N && S && (match = S.match(P))) {\r\n        const prefix =\r\n            // eslint-disable-next-line no-nested-ternary\r\n            match[0].length > 0 ? S.substr(0, match.index) : lastMatch === undefined ? '' : S.substr(0, 1)\r\n\r\n        lastMatch = match[0]\r\n        result += `${prefix}${REPL(match)}`\r\n        S = S.substr(`${prefix}${lastMatch}`.length)\r\n\r\n        count += 1\r\n    }\r\n\r\n    return `${result}${S}`\r\n}\r\n\r\n/**\r\n * Receives a string and returns its length. The empty string \"\" has length 0.\r\n * Embedded zeros are counted, so \"a\\000bc\\000\" has length 5.\r\n */\r\nfunction len(s: LuaType): number {\r\n    const str = coerceArgToString(s, 'len', 1)\r\n    return str.length\r\n}\r\n\r\n/**\r\n * Receives a string and returns a copy of this string with all uppercase letters changed to lowercase.\r\n * All other characters are left unchanged.\r\n * The definition of what an uppercase letter is depends on the current locale.\r\n */\r\nfunction lower(s: LuaType): string {\r\n    const str = coerceArgToString(s, 'lower', 1)\r\n    return str.toLowerCase()\r\n}\r\n\r\n/**\r\n * Looks for the first match of pattern (see §6.4.1) in the string s.\r\n * If it finds one, then match returns the captures from the pattern; otherwise it returns nil.\r\n * If pattern specifies no captures, then the whole match is returned.\r\n * A third, optional numeric argument init specifies where to start the search; its default value is 1 and can be negative.\r\n */\r\nfunction match(s: LuaType, pattern: LuaType, init: LuaType = 0): string | RegExpMatchArray {\r\n    let str = coerceArgToString(s, 'match', 1)\r\n    const patt = coerceArgToString(pattern, 'match', 2)\r\n    const ini = coerceArgToNumber(init, 'match', 3)\r\n\r\n    str = str.substr(ini)\r\n    const matches = str.match(new RegExp(translatePattern(patt)))\r\n\r\n    if (!matches) {\r\n        return\r\n    } else if (!matches[1]) {\r\n        return matches[0]\r\n    }\r\n\r\n    matches.shift()\r\n    return matches\r\n}\r\n\r\n/**\r\n * Returns a string that is the concatenation of n copies of the string s separated by the string sep.\r\n * The default value for sep is the empty string (that is, no separator).\r\n * Returns the empty string if n is not positive.\r\n */\r\nfunction rep(s: LuaType, n: LuaType, sep?: LuaType): string {\r\n    const str = coerceArgToString(s, 'rep', 1)\r\n    const num = coerceArgToNumber(n, 'rep', 2)\r\n    const SEP = sep === undefined ? '' : coerceArgToString(sep, 'rep', 3)\r\n    return Array(num)\r\n        .fill(str)\r\n        .join(SEP)\r\n}\r\n\r\n/** Returns a string that is the string s reversed. */\r\nfunction reverse(s: LuaType): string {\r\n    const str = coerceArgToString(s, 'reverse', 1)\r\n    return str\r\n        .split('')\r\n        .reverse()\r\n        .join('')\r\n}\r\n\r\n/**\r\n * Returns the substring of s that starts at i and continues until j; i and j can be negative.\r\n * If j is absent, then it is assumed to be equal to -1 (which is the same as the string length).\r\n * In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i)\r\n * (for a positive j) returns a suffix of s with length i.\r\n *\r\n * If, after the translation of negative indices, i is less than 1, it is corrected to 1. If j is greater than\r\n * the string length, it is corrected to that length. If, after these corrections, i is greater than j,\r\n * the function returns the empty string.\r\n */\r\nfunction sub(s: LuaType, i: LuaType = 1, j: LuaType = -1): string {\r\n    const S = coerceArgToString(s, 'sub', 1)\r\n    let start = posrelat(coerceArgToNumber(i, 'sub', 2), S.length)\r\n    let end = posrelat(coerceArgToNumber(j, 'sub', 3), S.length)\r\n\r\n    if (start < 1) start = 1\r\n    if (end > S.length) end = S.length\r\n\r\n    if (start <= end) return S.substr(start - 1, end - start + 1)\r\n    return ''\r\n}\r\n\r\n/**\r\n * Receives a string and returns a copy of this string with all lowercase letters changed to uppercase.\r\n * All other characters are left unchanged.\r\n * The definition of what a lowercase letter is depends on the current locale.\r\n */\r\nfunction upper(s: LuaType): string {\r\n    const S = coerceArgToString(s, 'upper', 1)\r\n    return S.toUpperCase()\r\n}\r\n\r\nconst libString = new Table({\r\n    byte,\r\n    char,\r\n    find,\r\n    format,\r\n    gmatch,\r\n    gsub,\r\n    len,\r\n    lower,\r\n    match,\r\n    rep,\r\n    reverse,\r\n    sub,\r\n    upper\r\n})\r\n\r\nconst metatable = new Table({ __index: libString })\r\n\r\nexport { libString, metatable }\r\n","import { parse } from '../parser'\r\nimport { Table } from '../Table'\r\nimport { LuaError } from '../LuaError'\r\nimport {\r\n    LuaType,\r\n    Config,\r\n    type,\r\n    tostring,\r\n    posrelat,\r\n    coerceToNumber,\r\n    coerceToString,\r\n    coerceToBoolean,\r\n    coerceArgToNumber,\r\n    coerceArgToString,\r\n    coerceArgToTable,\r\n    hasOwnProperty\r\n} from '../utils'\r\nimport { metatable as stringMetatable } from './string'\r\n\r\nconst CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\r\n\r\nfunction ipairsIterator(table: Table, index: number): LuaType[] {\r\n    if (index === undefined) {\r\n        throw new LuaError('Bad argument #2 to ipairs() iterator')\r\n    }\r\n\r\n    const nextIndex = index + 1\r\n    const numValues = table.numValues\r\n\r\n    if (!numValues[nextIndex] || numValues[nextIndex] === undefined) return undefined\r\n    return [nextIndex, numValues[nextIndex]]\r\n}\r\n\r\nconst _VERSION = 'Lua 5.3'\r\n\r\nfunction assert(v: LuaType, m?: LuaType): [unknown, unknown] {\r\n    if (coerceToBoolean(v)) return [v, m]\r\n\r\n    const msg = m === undefined ? 'Assertion failed!' : coerceArgToString(m, 'assert', 2)\r\n    throw new LuaError(msg)\r\n}\r\n\r\nfunction collectgarbage(): [] {\r\n    // noop\r\n    return []\r\n}\r\n\r\nfunction error(message: LuaType): void {\r\n    const msg = coerceArgToString(message, 'error', 1)\r\n    throw new LuaError(msg)\r\n}\r\n\r\n/**\r\n * If object does not have a metatable, returns nil.\r\n * Otherwise, if the object's metatable has a __metatable field, returns the associated value.\r\n * Otherwise, returns the metatable of the given object.\r\n */\r\nfunction getmetatable(table: LuaType): Table {\r\n    if (table instanceof Table && table.metatable) {\r\n        const mm = table.metatable.rawget('__metatable') as Table\r\n        return mm ? mm : table.metatable\r\n    }\r\n    if (typeof table === 'string') {\r\n        return stringMetatable\r\n    }\r\n}\r\n\r\n/**\r\n * Returns three values (an iterator function, the table t, and 0) so that the construction\r\n *\r\n *      `for i,v in ipairs(t) do body end`\r\n *\r\n * will iterate over the key–value pairs (1,t[1]), (2,t[2]), ..., up to the first nil value.\r\n */\r\nfunction ipairs(t: LuaType): [Function, Table, number] {\r\n    const table = coerceArgToTable(t, 'ipairs', 1)\r\n    const mm = table.getMetaMethod('__pairs') || table.getMetaMethod('__ipairs')\r\n    return mm ? mm(table).slice(0, 3) : [ipairsIterator, table, 0]\r\n}\r\n\r\n/**\r\n * Allows a program to traverse all fields of a table.\r\n * Its first argument is a table and its second argument is an index in this table.\r\n * next returns the next index of the table and its associated value.\r\n * When called with nil as its second argument, next returns an initial index and its associated value.\r\n * When called with the last index, or with nil in an empty table, next returns nil.\r\n * If the second argument is absent, then it is interpreted as nil.\r\n * In particular, you can use next(t) to check whether a table is empty.\r\n *\r\n * The order in which the indices are enumerated is not specified, even for numeric indices.\r\n * (To traverse a table in numerical order, use a numerical for.)\r\n *\r\n * The behavior of next is undefined if, during the traversal, you assign any value to a non-existent field in the table.\r\n * You may however modify existing fields. In particular, you may clear existing fields.\r\n */\r\nfunction next(table: LuaType, index?: LuaType): [number | string, LuaType] {\r\n    const TABLE = coerceArgToTable(table, 'next', 1)\r\n\r\n    // SLOOOOOOOW...\r\n    let found = index === undefined\r\n\r\n    if (found || (typeof index === 'number' && index > 0)) {\r\n        const numValues = TABLE.numValues\r\n        const keys = Object.keys(numValues)\r\n        let i = 1\r\n\r\n        if (!found) {\r\n            const I = keys.indexOf(`${index}`)\r\n            if (I >= 0) {\r\n                found = true\r\n                i += I\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            for (i; keys[i] !== undefined; i++) {\r\n                const key = Number(keys[i])\r\n                const value = numValues[key]\r\n                if (value !== undefined) return [key, value]\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const i in TABLE.strValues) {\r\n        if (hasOwnProperty(TABLE.strValues, i)) {\r\n            if (!found) {\r\n                if (i === index) found = true\r\n            } else if (TABLE.strValues[i] !== undefined) {\r\n                return [i, TABLE.strValues[i]]\r\n            }\r\n        }\r\n    }\r\n\r\n    for (const i in TABLE.keys) {\r\n        if (hasOwnProperty(TABLE.keys, i)) {\r\n            const key = TABLE.keys[i]\r\n\r\n            if (!found) {\r\n                if (key === index) found = true\r\n            } else if (TABLE.values[i] !== undefined) {\r\n                return [key, TABLE.values[i]]\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * If t has a metamethod __pairs, calls it with t as argument and returns the first three results from the call.\r\n *\r\n * Otherwise, returns three values: the next function, the table t, and nil, so that the construction\r\n *\r\n *      `for k,v in pairs(t) do body end`\r\n *\r\n * will iterate over all key–value pairs of table t.\r\n *\r\n * See function next for the caveats of modifying the table during its traversal.\r\n */\r\nfunction pairs(t: LuaType): [Function, Table, undefined] {\r\n    const table = coerceArgToTable(t, 'pairs', 1)\r\n    const mm = table.getMetaMethod('__pairs')\r\n    return mm ? mm(table).slice(0, 3) : [next, table, undefined]\r\n}\r\n\r\n/**\r\n * Calls function f with the given arguments in protected mode.\r\n * This means that any error inside f is not propagated;\r\n * instead, pcall catches the error and returns a status code.\r\n * Its first result is the status code (a boolean), which is true if the call succeeds without errors.\r\n * In such case, pcall also returns all results from the call, after this first result.\r\n * In case of any error, pcall returns false plus the error message.\r\n */\r\nfunction pcall(f: LuaType, ...args: LuaType[]): [false, string] | [true, ...LuaType[]] {\r\n    if (typeof f !== 'function') {\r\n        throw new LuaError('Attempt to call non-function')\r\n    }\r\n\r\n    try {\r\n        return [true, ...f(...args)]\r\n    } catch (e) {\r\n        return [false, e && e.toString()]\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether v1 is equal to v2, without invoking the __eq metamethod. Returns a boolean.\r\n */\r\nfunction rawequal(v1: LuaType, v2: LuaType): boolean {\r\n    return v1 === v2\r\n}\r\n\r\n/**\r\n * Gets the real value of table[index], without invoking the __index metamethod.\r\n * table must be a table; index may be any value.\r\n */\r\nfunction rawget(table: LuaType, index: LuaType): LuaType {\r\n    const TABLE = coerceArgToTable(table, 'rawget', 1)\r\n    return TABLE.rawget(index)\r\n}\r\n\r\n/**\r\n * Returns the length of the object v, which must be a table or a string, without invoking the __len metamethod.\r\n * Returns an integer.\r\n */\r\nfunction rawlen(v: LuaType): number {\r\n    if (v instanceof Table) return v.getn()\r\n\r\n    if (typeof v === 'string') return v.length\r\n\r\n    throw new LuaError('attempt to get length of an unsupported value')\r\n}\r\n\r\n/**\r\n * Sets the real value of table[index] to value, without invoking the __newindex metamethod.\r\n * table must be a table, index any value different from nil and NaN, and value any Lua value.\r\n *\r\n * This function returns table.\r\n */\r\nfunction rawset(table: LuaType, index: LuaType, value: LuaType): Table {\r\n    const TABLE = coerceArgToTable(table, 'rawset', 1)\r\n    if (index === undefined) throw new LuaError('table index is nil')\r\n\r\n    TABLE.rawset(index, value)\r\n    return TABLE\r\n}\r\n\r\n/**\r\n * If index is a number, returns all arguments after argument number index;\r\n * a negative number indexes from the end (-1 is the last argument).\r\n * Otherwise, index must be the string \"#\", and select returns the total number of extra arguments it received.\r\n */\r\nfunction select(index: number | '#', ...args: LuaType[]): LuaType[] | number {\r\n    if (index === '#') {\r\n        return args.length\r\n    }\r\n\r\n    if (typeof index === 'number') {\r\n        const pos = posrelat(Math.trunc(index), args.length)\r\n        return args.slice(pos - 1)\r\n    }\r\n\r\n    throw new LuaError(`bad argument #1 to 'select' (number expected, got ${type(index)})`)\r\n}\r\n\r\n/**\r\n * Sets the metatable for the given table.\r\n * (To change the metatable of other types from Lua code,you must use the debug library (§6.10).)\r\n * If metatable is nil, removes the metatable of the given table.\r\n * If the original metatable has a __metatable field, raises an error.\r\n *\r\n * This function returns table.\r\n */\r\nfunction setmetatable(table: LuaType, metatable: LuaType): Table {\r\n    const TABLE = coerceArgToTable(table, 'setmetatable', 1)\r\n\r\n    if (TABLE.metatable && TABLE.metatable.rawget('__metatable')) {\r\n        throw new LuaError('cannot change a protected metatable')\r\n    }\r\n\r\n    TABLE.metatable = coerceArgToTable(metatable, 'setmetatable', 2)\r\n    return TABLE\r\n}\r\n\r\n/**\r\n * When called with no base, tonumber tries to convert its argument to a number.\r\n * If the argument is already a number or a string convertible to a number,\r\n * then tonumber returns this number; otherwise, it returns nil.\r\n *\r\n * The conversion of strings can result in integers or floats,\r\n * according to the lexical conventions of Lua (see §3.1).\r\n * (The string may have leading and trailing spaces and a sign.)\r\n *\r\n * When called with base, then e must be a string to be interpreted as an integer numeral in that base.\r\n * The base may be any integer between 2 and 36, inclusive.\r\n * In bases above 10, the letter 'A' (in either upper or lower case) represents 10,\r\n * 'B' represents 11, and so forth, with 'Z' representing 35.\r\n * If the string e is not a valid numeral in the given base, the function returns nil.\r\n */\r\nfunction tonumber(e: LuaType, base: LuaType): number {\r\n    const E = coerceToString(e).trim()\r\n    const BASE = base === undefined ? 10 : coerceArgToNumber(base, 'tonumber', 2)\r\n\r\n    if (BASE !== 10 && E === 'nil') {\r\n        throw new LuaError(\"bad argument #1 to 'tonumber' (string expected, got nil)\")\r\n    }\r\n\r\n    if (BASE < 2 || BASE > 36) {\r\n        throw new LuaError(`bad argument #2 to 'tonumber' (base out of range)`)\r\n    }\r\n\r\n    if (E === '') return\r\n    if (BASE === 10) return coerceToNumber(E)\r\n\r\n    const pattern = new RegExp(`^${BASE === 16 ? '(0x)?' : ''}[${CHARS.substr(0, BASE)}]*$`, 'gi')\r\n\r\n    if (!pattern.test(E)) return // Invalid\r\n    return parseInt(E, BASE)\r\n}\r\n\r\n/**\r\n * This function is similar to pcall, except that it sets a new message handler msgh.\r\n */\r\nfunction xpcall(f: LuaType, msgh: LuaType, ...args: LuaType[]): [false, string] | [true, ...LuaType[]] {\r\n    if (typeof f !== 'function' || typeof msgh !== 'function') {\r\n        throw new LuaError('Attempt to call non-function')\r\n    }\r\n\r\n    try {\r\n        return [true, ...f(...args)]\r\n    } catch (e) {\r\n        return [false, msgh(e)[0]]\r\n    }\r\n}\r\n\r\nfunction createG(cfg: Config, execChunk: (_G: Table, chunk: string) => LuaType[]): Table {\r\n    function print(...args: LuaType[]): void {\r\n        const output = args.map(arg => tostring(arg)).join('\\t')\r\n        cfg.stdout(output)\r\n    }\r\n\r\n    function load(\r\n        chunk: LuaType,\r\n        _chunkname?: string,\r\n        _mode?: 'b' | 't' | 'bt',\r\n        env?: Table\r\n    ): [undefined, string] | (() => LuaType[]) {\r\n        let C = ''\r\n        if (chunk instanceof Function) {\r\n            let ret = ' '\r\n            while (ret !== '' && ret !== undefined) {\r\n                C += ret\r\n                ret = chunk()[0]\r\n            }\r\n        } else {\r\n            C = coerceArgToString(chunk, 'load', 1)\r\n        }\r\n\r\n        let parsed: string\r\n        try {\r\n            parsed = parse(C)\r\n        } catch (e) {\r\n            return [undefined, e.message]\r\n        }\r\n\r\n        return () => execChunk(env || _G, parsed)\r\n    }\r\n\r\n    function dofile(filename?: LuaType): LuaType[] {\r\n        const res = loadfile(filename)\r\n\r\n        if (Array.isArray(res) && res[0] === undefined) {\r\n            throw new LuaError(res[1])\r\n        }\r\n\r\n        const exec = res as () => LuaType[]\r\n        return exec()\r\n    }\r\n\r\n    function loadfile(\r\n        filename?: LuaType,\r\n        mode?: 'b' | 't' | 'bt',\r\n        env?: Table\r\n    ): [undefined, string] | (() => LuaType[]) {\r\n        const FILENAME = filename === undefined ? cfg.stdin : coerceArgToString(filename, 'loadfile', 1)\r\n\r\n        if (!cfg.fileExists) {\r\n            throw new LuaError('loadfile requires the config.fileExists function')\r\n        }\r\n\r\n        if (!cfg.fileExists(FILENAME)) return [undefined, 'file not found']\r\n\r\n        if (!cfg.loadFile) {\r\n            throw new LuaError('loadfile requires the config.loadFile function')\r\n        }\r\n\r\n        return load(cfg.loadFile(FILENAME), FILENAME, mode, env)\r\n    }\r\n\r\n    const _G = new Table({\r\n        _VERSION,\r\n        assert,\r\n        dofile,\r\n        collectgarbage,\r\n        error,\r\n        getmetatable,\r\n        ipairs,\r\n        load,\r\n        loadfile,\r\n        next,\r\n        pairs,\r\n        pcall,\r\n        print,\r\n        rawequal,\r\n        rawget,\r\n        rawlen,\r\n        rawset,\r\n        select,\r\n        setmetatable,\r\n        tonumber,\r\n        tostring,\r\n        type,\r\n        xpcall\r\n    })\r\n\r\n    return _G\r\n}\r\n\r\nexport { tostring, createG }\r\n","import { MetaMethods, Table } from './Table'\r\nimport { coerceToNumber, coerceToString, LuaType, coerceToBoolean } from './utils'\r\nimport { LuaError } from './LuaError'\r\n\r\nconst binaryArithmetic = <R extends boolean | number>(\r\n    left: LuaType,\r\n    right: LuaType,\r\n    metaMethodName: MetaMethods,\r\n    callback: (l: number, r: number) => R\r\n): R => {\r\n    const mm =\r\n        (left instanceof Table && left.getMetaMethod(metaMethodName)) ||\r\n        (right instanceof Table && right.getMetaMethod(metaMethodName))\r\n    if (mm) return mm(left, right)[0]\r\n\r\n    const L = coerceToNumber(left, 'attempt to perform arithmetic on a %type value')\r\n    const R = coerceToNumber(right, 'attempt to perform arithmetic on a %type value')\r\n    return callback(L, R)\r\n}\r\n\r\nconst binaryBooleanArithmetic = (\r\n    left: LuaType,\r\n    right: LuaType,\r\n    metaMethodName: MetaMethods,\r\n    callback: (l: LuaType, r: LuaType) => boolean\r\n): boolean => {\r\n    if (\r\n        (typeof left === 'string' && typeof right === 'string') ||\r\n        (typeof left === 'number' && typeof right === 'number')\r\n    ) {\r\n        return callback(left, right)\r\n    }\r\n    return binaryArithmetic<boolean>(left, right, metaMethodName, callback)\r\n}\r\n\r\n// extra\r\nconst bool = (value: LuaType): boolean => coerceToBoolean(value)\r\n\r\n// unary\r\nconst not = (value: LuaType): boolean => !bool(value)\r\n\r\nconst unm = (value: LuaType): number => {\r\n    const mm = value instanceof Table && value.getMetaMethod('__unm')\r\n    if (mm) return mm(value)[0]\r\n\r\n    return -1 * coerceToNumber(value, 'attempt to perform arithmetic on a %type value')\r\n}\r\n\r\nconst bnot = (value: LuaType): number => {\r\n    const mm = value instanceof Table && value.getMetaMethod('__bnot')\r\n    if (mm) return mm(value)[0]\r\n\r\n    return ~coerceToNumber(value, 'attempt to perform arithmetic on a %type value')\r\n}\r\n\r\nconst len = (value: LuaType): number => {\r\n    if (value instanceof Table) {\r\n        const mm = value.getMetaMethod('__len')\r\n        if (mm) return mm(value)[0]\r\n\r\n        return value.getn()\r\n    }\r\n\r\n    if (typeof value === 'string') return value.length\r\n\r\n    throw new LuaError('attempt to get length of an unsupported value')\r\n\r\n    // if (typeof value === 'object') {\r\n    //     let length = 0\r\n    //     for (const key in value) {\r\n    //         if (hasOwnProperty(value, key)) {\r\n    //             length += 1\r\n    //         }\r\n    //     }\r\n    //     return length\r\n    // }\r\n}\r\n\r\n// binary\r\nconst add = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__add', (l, r) => l + r)\r\n\r\nconst sub = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__sub', (l, r) => l - r)\r\n\r\nconst mul = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__mul', (l, r) => l * r)\r\n\r\nconst mod = (left: LuaType, right: LuaType): number =>\r\n    binaryArithmetic(left, right, '__mod', (l, r) => {\r\n        if (r === 0 || r === -Infinity || r === Infinity || isNaN(l) || isNaN(r)) return NaN\r\n\r\n        const absR = Math.abs(r)\r\n        let result = Math.abs(l) % absR\r\n\r\n        if (l * r < 0) result = absR - result\r\n        if (r < 0) result *= -1\r\n\r\n        return result\r\n    })\r\n\r\nconst pow = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__pow', Math.pow)\r\n\r\nconst div = (left: LuaType, right: LuaType): number =>\r\n    binaryArithmetic(left, right, '__div', (l, r) => {\r\n        if (r === undefined) throw new LuaError('attempt to perform arithmetic on a nil value')\r\n        return l / r\r\n    })\r\n\r\nconst idiv = (left: LuaType, right: LuaType): number =>\r\n    binaryArithmetic(left, right, '__idiv', (l, r) => {\r\n        if (r === undefined) throw new LuaError('attempt to perform arithmetic on a nil value')\r\n        return Math.floor(l / r)\r\n    })\r\n\r\nconst band = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__band', (l, r) => l & r)\r\n\r\nconst bor = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__bor', (l, r) => l | r)\r\n\r\nconst bxor = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__bxor', (l, r) => l ^ r)\r\n\r\nconst shl = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__shl', (l, r) => l << r)\r\n\r\nconst shr = (left: LuaType, right: LuaType): number => binaryArithmetic(left, right, '__shr', (l, r) => l >> r)\r\n\r\nconst concat = (left: LuaType, right: LuaType): string => {\r\n    const mm =\r\n        (left instanceof Table && left.getMetaMethod('__concat')) ||\r\n        (right instanceof Table && right.getMetaMethod('__concat'))\r\n    if (mm) return mm(left, right)[0]\r\n\r\n    const L = coerceToString(left, 'attempt to concatenate a %type value')\r\n    const R = coerceToString(right, 'attempt to concatenate a %type value')\r\n    return `${L}${R}`\r\n}\r\n\r\nconst neq = (left: LuaType, right: LuaType): boolean => !eq(left, right)\r\n\r\nconst eq = (left: LuaType, right: LuaType): boolean => {\r\n    const mm =\r\n        right !== left &&\r\n        left instanceof Table &&\r\n        right instanceof Table &&\r\n        left.metatable === right.metatable &&\r\n        left.getMetaMethod('__eq')\r\n\r\n    if (mm) return !!mm(left, right)[0]\r\n\r\n    return left === right\r\n}\r\n\r\nconst lt = (left: LuaType, right: LuaType): boolean => binaryBooleanArithmetic(left, right, '__lt', (l, r) => l < r)\r\n\r\nconst le = (left: LuaType, right: LuaType): boolean => binaryBooleanArithmetic(left, right, '__le', (l, r) => l <= r)\r\n\r\nconst gt = (left: LuaType, right: LuaType): boolean => !le(left, right)\r\n\r\nconst ge = (left: LuaType, right: LuaType): boolean => !lt(left, right)\r\n\r\nconst operators = {\r\n    bool,\r\n    not,\r\n    unm,\r\n    bnot,\r\n    len,\r\n    add,\r\n    sub,\r\n    mul,\r\n    mod,\r\n    pow,\r\n    div,\r\n    idiv,\r\n    band,\r\n    bor,\r\n    bxor,\r\n    shl,\r\n    shr,\r\n    concat,\r\n    neq,\r\n    eq,\r\n    lt,\r\n    le,\r\n    gt,\r\n    ge\r\n}\r\n\r\nexport { operators }\r\n","import { Table } from '../Table'\r\nimport { coerceArgToNumber, LuaType, coerceToNumber } from '../utils'\r\n\r\nconst maxinteger = Number.MAX_SAFE_INTEGER\r\nconst mininteger = Number.MIN_SAFE_INTEGER\r\nconst huge = Infinity\r\nconst pi = Math.PI\r\n\r\nlet randomSeed = 1\r\n\r\nfunction getRandom(): number {\r\n    randomSeed = (16807 * randomSeed) % 2147483647\r\n    return randomSeed / 2147483647\r\n}\r\n\r\nfunction abs(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'abs', 1)\r\n    return Math.abs(X)\r\n}\r\n\r\nfunction acos(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'acos', 1)\r\n    return Math.acos(X)\r\n}\r\n\r\nfunction asin(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'asin', 1)\r\n    return Math.asin(X)\r\n}\r\n\r\nfunction atan(y: LuaType, x?: LuaType): number {\r\n    const Y = coerceArgToNumber(y, 'atan', 1)\r\n    const X = x === undefined ? 1 : coerceArgToNumber(x, 'atan', 2)\r\n    return Math.atan2(Y, X)\r\n}\r\n\r\nfunction atan2(y: LuaType, x: LuaType): number {\r\n    return atan(y, x)\r\n}\r\n\r\nfunction ceil(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'ceil', 1)\r\n    return Math.ceil(X)\r\n}\r\n\r\nfunction cos(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'cos', 1)\r\n    return Math.cos(X)\r\n}\r\n\r\nfunction cosh(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'cosh', 1)\r\n    return (exp(X) + exp(-X)) / 2\r\n}\r\n\r\nfunction deg(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'deg', 1)\r\n    return (X * 180) / Math.PI\r\n}\r\n\r\nfunction exp(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'exp', 1)\r\n    return Math.exp(X)\r\n}\r\n\r\nfunction floor(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'floor', 1)\r\n    return Math.floor(X)\r\n}\r\n\r\nfunction fmod(x: LuaType, y: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'fmod', 1)\r\n    const Y = coerceArgToNumber(y, 'fmod', 2)\r\n    return X % Y\r\n}\r\n\r\nfunction frexp(x: LuaType): number[] {\r\n    let X = coerceArgToNumber(x, 'frexp', 1)\r\n\r\n    if (X === 0) {\r\n        return [0, 0]\r\n    }\r\n\r\n    const delta = X > 0 ? 1 : -1\r\n    X *= delta\r\n\r\n    const exponent = Math.floor(Math.log(X) / Math.log(2)) + 1\r\n    const mantissa = X / Math.pow(2, exponent)\r\n\r\n    return [mantissa * delta, exponent]\r\n}\r\n\r\nfunction ldexp(m: LuaType, e: LuaType): number {\r\n    const M = coerceArgToNumber(m, 'ldexp', 1)\r\n    const E = coerceArgToNumber(e, 'ldexp', 2)\r\n    return M * Math.pow(2, E)\r\n}\r\n\r\nfunction log(x: LuaType, base?: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'log', 1)\r\n    if (base === undefined) {\r\n        return Math.log(X)\r\n    } else {\r\n        const B = coerceArgToNumber(base, 'log', 2)\r\n        return Math.log(X) / Math.log(B)\r\n    }\r\n}\r\n\r\nfunction log10(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'log10', 1)\r\n    // v5.2: warn ('math.log10 is deprecated. Use math.log with 10 as its second argument instead.');\r\n    return Math.log(X) / Math.log(10)\r\n}\r\n\r\nfunction max(...args: LuaType[]): number {\r\n    const ARGS = args.map((n, i) => coerceArgToNumber(n, 'max', i + 1))\r\n    return Math.max(...ARGS)\r\n}\r\n\r\nfunction min(...args: LuaType[]): number {\r\n    const ARGS = args.map((n, i) => coerceArgToNumber(n, 'min', i + 1))\r\n    return Math.min(...ARGS)\r\n}\r\n\r\nfunction modf(x: LuaType): number[] {\r\n    const X = coerceArgToNumber(x, 'modf', 1)\r\n    const intValue = Math.floor(X)\r\n    const mantissa = X - intValue\r\n    return [intValue, mantissa]\r\n}\r\n\r\nfunction pow(x: LuaType, y: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'pow', 1)\r\n    const Y = coerceArgToNumber(y, 'pow', 2)\r\n    return Math.pow(X, Y)\r\n}\r\n\r\nfunction rad(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'rad', 1)\r\n    return (Math.PI / 180) * X\r\n}\r\n\r\nfunction random(min?: LuaType, max?: LuaType): number {\r\n    if (min === undefined && max === undefined) return getRandom()\r\n    const firstArg = coerceArgToNumber(min, 'random', 1)\r\n    const MIN = max === undefined ? firstArg : 1\r\n    const MAX = max === undefined ? coerceArgToNumber(max, 'random', 2) : firstArg\r\n\r\n    if (MIN > MAX) throw new Error(\"bad argument #2 to 'random' (interval is empty)\")\r\n    return Math.floor(getRandom() * (MAX - MIN + 1) + MIN)\r\n}\r\n\r\nfunction randomseed(x: LuaType): void {\r\n    randomSeed = coerceArgToNumber(x, 'randomseed', 1)\r\n}\r\n\r\nfunction sin(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'sin', 1)\r\n    return Math.sin(X)\r\n}\r\n\r\nfunction sinh(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'sinh', 1)\r\n    return (exp(X) - exp(-X)) / 2\r\n}\r\n\r\nfunction sqrt(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'sqrt', 1)\r\n    return Math.sqrt(X)\r\n}\r\n\r\nfunction tan(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'tan', 1)\r\n    return Math.tan(X)\r\n}\r\n\r\nfunction tanh(x: LuaType): number {\r\n    const X = coerceArgToNumber(x, 'tanh', 1)\r\n    return (exp(X) - exp(-X)) / (exp(X) + exp(-X))\r\n}\r\n\r\nfunction tointeger(x: LuaType): number {\r\n    const X = coerceToNumber(x)\r\n    if (X === undefined) return undefined\r\n    return Math.floor(X)\r\n}\r\n\r\nfunction type(x: LuaType): string {\r\n    const X = coerceToNumber(x)\r\n    if (X === undefined) return undefined\r\n    if (tointeger(X) === X) return 'integer'\r\n    return 'float'\r\n}\r\n\r\nfunction ult(m: LuaType, n: LuaType): boolean {\r\n    const M = coerceArgToNumber(m, 'ult', 1)\r\n    const N = coerceArgToNumber(n, 'ult', 2)\r\n\r\n    const toUnsigned = (n: number): number => n >>> 0\r\n    return toUnsigned(M) < toUnsigned(N)\r\n}\r\n\r\nconst libMath = new Table({\r\n    abs,\r\n    acos,\r\n    asin,\r\n    atan,\r\n    atan2,\r\n    ceil,\r\n    cos,\r\n    cosh,\r\n    deg,\r\n    exp,\r\n    floor,\r\n    fmod,\r\n    frexp,\r\n    huge,\r\n    ldexp,\r\n    log,\r\n    log10,\r\n    max,\r\n    min,\r\n    maxinteger,\r\n    mininteger,\r\n    modf,\r\n    pi,\r\n    pow,\r\n    rad,\r\n    random,\r\n    randomseed,\r\n    sin,\r\n    sinh,\r\n    sqrt,\r\n    tan,\r\n    tanh,\r\n    tointeger,\r\n    type,\r\n    ult\r\n})\r\n\r\nexport { libMath }\r\n","import { Table } from '../Table'\r\nimport {\r\n    LuaType,\r\n    coerceToBoolean,\r\n    coerceArgToNumber,\r\n    coerceArgToString,\r\n    coerceArgToTable,\r\n    coerceArgToFunction\r\n} from '../utils'\r\nimport { LuaError } from '../LuaError'\r\n\r\nfunction getn(table: LuaType): number {\r\n    const TABLE = coerceArgToTable(table, 'getn', 1)\r\n    return TABLE.getn()\r\n}\r\n\r\n/**\r\n * Given a list where all elements are strings or numbers, returns the string list[i]..sep..list[i+1] ··· sep..list[j].\r\n * The default value for sep is the empty string, the default for i is 1, and the default for j is #list.\r\n * If i is greater than j, returns the empty string.\r\n */\r\nfunction concat(table: LuaType, sep: LuaType = '', i: LuaType = 1, j?: LuaType): string {\r\n    const TABLE = coerceArgToTable(table, 'concat', 1)\r\n    const SEP = coerceArgToString(sep, 'concat', 2)\r\n    const I = coerceArgToNumber(i, 'concat', 3)\r\n    const J = j === undefined ? maxn(TABLE) : coerceArgToNumber(j, 'concat', 4)\r\n\r\n    return []\r\n        .concat(TABLE.numValues)\r\n        .splice(I, J - I + 1)\r\n        .join(SEP)\r\n}\r\n\r\n/**\r\n * Inserts element value at position pos in list, shifting up the elements list[pos], list[pos+1], ···, list[#list].\r\n * The default value for pos is #list+1, so that a call table.insert(t,x) inserts x at the end of list t.\r\n */\r\nfunction insert(table: LuaType, pos: LuaType, value?: LuaType): void {\r\n    const TABLE = coerceArgToTable(table, 'insert', 1)\r\n    const POS = value === undefined ? TABLE.numValues.length : coerceArgToNumber(pos, 'insert', 2)\r\n    const VALUE = value === undefined ? pos : value\r\n\r\n    TABLE.numValues.splice(POS, 0, undefined)\r\n    TABLE.set(POS, VALUE)\r\n}\r\n\r\nfunction maxn(table: LuaType): number {\r\n    const TABLE = coerceArgToTable(table, 'maxn', 1)\r\n    return TABLE.numValues.length - 1\r\n}\r\n\r\n/**\r\n * Moves elements from table a1 to table a2, performing the equivalent to the following multiple assignment:\r\n *\r\n *      `a2[t],··· = a1[f],···,a1[e].`\r\n *\r\n * The default for a2 is a1.\r\n * The destination range can overlap with the source range.\r\n * The number of elements to be moved must fit in a Lua integer.\r\n *\r\n * Returns the destination table a2.\r\n */\r\nfunction move(a1: LuaType, f: LuaType, e: LuaType, t: LuaType, a2?: LuaType): Table {\r\n    const A1 = coerceArgToTable(a1, 'move', 1)\r\n    const F = coerceArgToNumber(f, 'move', 2)\r\n    const E = coerceArgToNumber(e, 'move', 3)\r\n    const T = coerceArgToNumber(t, 'move', 4)\r\n    const A2 = a2 === undefined ? A1 : coerceArgToTable(a2, 'move', 5)\r\n\r\n    if (E >= F) {\r\n        if (F <= 0 && E >= Number.MAX_SAFE_INTEGER + F) throw new LuaError('too many elements to move')\r\n        const n = E - F + 1 // number of elements to movea\r\n        if (T > Number.MAX_SAFE_INTEGER - n + 1) throw new LuaError('destination wrap around')\r\n\r\n        if (T > E || T <= F || A2 !== A1) {\r\n            for (let i = 0; i < n; i++) {\r\n                const v = A1.get(F + i)\r\n                A2.set(T + i, v)\r\n            }\r\n        } else {\r\n            for (let i = n - 1; i >= 0; i--) {\r\n                const v = A1.get(F + i)\r\n                A2.set(T + i, v)\r\n            }\r\n        }\r\n    }\r\n\r\n    return A2\r\n}\r\n\r\n/**\r\n * Returns a new table with all arguments stored into keys 1, 2, etc. and with a field \"n\" with the total number of arguments.\r\n * Note that the resulting table may not be a sequence.\r\n */\r\nfunction pack(...args: LuaType[]): Table {\r\n    const table = new Table(args)\r\n    table.rawset('n', args.length)\r\n    return table\r\n}\r\n\r\n/**\r\n * Removes from list the element at position pos, returning the value of the removed element.\r\n * When pos is an integer between 1 and #list, it shifts down the elements list[pos+1], list[pos+2], ···, list[#list] and\r\n * erases element list[#list]; The index pos can also be 0 when #list is 0, or #list + 1;\r\n * in those cases, the function erases the element list[pos].\r\n *\r\n * The default value for pos is #list, so that a call table.remove(l) removes the last element of list l.\r\n */\r\nfunction remove(table: LuaType, pos?: LuaType): LuaType {\r\n    const TABLE = coerceArgToTable(table, 'remove', 1)\r\n    const max = TABLE.getn()\r\n    const POS = pos === undefined ? max : coerceArgToNumber(pos, 'remove', 2)\r\n\r\n    if (POS > max || POS < 0) {\r\n        return\r\n    }\r\n\r\n    const vals = TABLE.numValues\r\n    const result = vals.splice(POS, 1)[0]\r\n\r\n    let i = POS\r\n    while (i < max && vals[i] === undefined) {\r\n        delete vals[i]\r\n        i += 1\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n/**\r\n * Sorts list elements in a given order, in-place, from list[1] to list[#list].\r\n * If comp is given, then it must be a function that receives two list elements and\r\n * returns true when the first element must come before the second in the final order\r\n * (so that, after the sort, i < j implies not comp(list[j],list[i])).\r\n * If comp is not given, then the standard Lua operator < is used instead.\r\n *\r\n * Note that the comp function must define a strict partial order over the elements in the list;\r\n * that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.\r\n *\r\n * The sort algorithm is not stable: elements considered equal by the given order may have\r\n * their relative positions changed by the sort.\r\n */\r\nfunction sort(table: Table, comp?: Function): void {\r\n    const TABLE = coerceArgToTable(table, 'sort', 1)\r\n\r\n    let sortFunc: (a: LuaType, b: LuaType) => number\r\n\r\n    if (comp) {\r\n        const COMP = coerceArgToFunction(comp, 'sort', 2)\r\n        sortFunc = (a, b) => (coerceToBoolean(COMP(a, b)[0]) ? -1 : 1)\r\n    } else {\r\n        sortFunc = (a, b) => (a < b ? -1 : 1)\r\n    }\r\n\r\n    const arr = TABLE.numValues\r\n    arr.shift()\r\n    arr.sort(sortFunc).unshift(undefined)\r\n}\r\n\r\n/**\r\n * Returns the elements from the given list. This function is equivalent to\r\n *\r\n *      `return list[i], list[i+1], ···, list[j]`\r\n *\r\n * By default, i is 1 and j is #list.\r\n */\r\nfunction unpack(table: LuaType, i?: LuaType, j?: LuaType): LuaType[] {\r\n    const TABLE = coerceArgToTable(table, 'unpack', 1)\r\n    const I = i === undefined ? 1 : coerceArgToNumber(i, 'unpack', 2)\r\n    const J = j === undefined ? TABLE.getn() : coerceArgToNumber(j, 'unpack', 3)\r\n\r\n    return TABLE.numValues.slice(I, J + 1)\r\n}\r\n\r\nconst libTable = new Table({\r\n    getn,\r\n    concat,\r\n    insert,\r\n    maxn,\r\n    move,\r\n    pack,\r\n    remove,\r\n    sort,\r\n    unpack\r\n})\r\n\r\nexport { libTable }\r\n","import { Table } from '../Table'\r\nimport { LuaType, Config, coerceArgToNumber } from '../utils'\r\nimport { LuaError } from '../LuaError'\r\n\r\nconst DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\r\nconst MONTHS = [\r\n    'January',\r\n    'February',\r\n    'March',\r\n    'April',\r\n    'May',\r\n    'June',\r\n    'July',\r\n    'August',\r\n    'September',\r\n    'October',\r\n    'November',\r\n    'December'\r\n]\r\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\r\n\r\n// LUA uses strftime internally (https://en.cppreference.com/w/c/chrono/strftime)\r\ntype Format =\r\n    | '%' // [string] literal %\r\n    | 'Y' // [number] year (e.g. 2017)\r\n    | 'y' // [number] last 2 digits of year (range [00,99])\r\n    | 'b' // [string] abbreviated month name (e.g. Oct)\r\n    | 'B' // [string] full month name (e.g. October)\r\n    | 'm' // [number] month (range [01,12])\r\n    | 'U' // [number] week of the year (Sunday is the first day of the week) (range [00,53])\r\n    | 'W' // [number] week of the year (Monday is the first day of the week) (range [00,53])\r\n    | 'j' // [number] day of the year (range [001,366])\r\n    | 'd' // [number] day of the month (range [01,31])\r\n    | 'a' // [string] abbreviated weekday name (e.g. Fri)\r\n    | 'A' // [string] full weekday name (e.g. Friday)\r\n    | 'w' // [number] weekday - Sunday is 0 (range [0-6])\r\n    | 'H' // [number] hour - 24 hour format (range [00-23])\r\n    | 'I' // [number] hour - 12 hour format (range [01,12])\r\n    | 'M' // [number] minute (range [00,59])\r\n    | 'S' // [number] second (range [00,60])\r\n    | 'c' // [string] standard date and time string (e.g. Sun Oct 17 04:41:13 2010)\r\n    | 'x' // [string] date (e.g. 09/16/98)\r\n    | 'X' // [string] time (e.g. 23:48:10)\r\n    | 'p' // [string] a.m. or p.m.\r\n    | 'Z' // [string] locale-dependent time zone name or abbreviation (e.g. UTC)\r\n\r\nconst DATE_FORMAT_HANDLERS: Record<Format, (date: Date, utc: boolean) => string> = {\r\n    '%': () => '%',\r\n    Y: (date, utc) => `${utc ? date.getUTCFullYear() : date.getFullYear()}`,\r\n    y: (date, utc) => DATE_FORMAT_HANDLERS.Y(date, utc).substr(-2),\r\n    b: (date, utc) => DATE_FORMAT_HANDLERS.B(date, utc).substr(0, 3),\r\n    B: (date, utc) => MONTHS[utc ? date.getUTCMonth() : date.getMonth()],\r\n    m: (date, utc) => `0${(utc ? date.getUTCMonth() : date.getMonth()) + 1}`.substr(-2),\r\n    U: (date, utc) => getWeekOfYear(date, 0, utc),\r\n    W: (date, utc) => getWeekOfYear(date, 1, utc),\r\n    j: (date, utc) => {\r\n        let result = utc ? date.getUTCDate() : date.getDate()\r\n        const month = utc ? date.getUTCMonth() : date.getMonth()\r\n        const year = utc ? date.getUTCFullYear() : date.getFullYear()\r\n\r\n        result += DAYS_IN_MONTH.slice(0, month).reduce((sum, n) => sum + n, 0)\r\n\r\n        if (month > 1 && year % 4 === 0) {\r\n            result += 1\r\n        }\r\n\r\n        return `00${result}`.substr(-3)\r\n    },\r\n    d: (date, utc) => `0${utc ? date.getUTCDate() : date.getDate()}`.substr(-2),\r\n    a: (date, utc) => DATE_FORMAT_HANDLERS.A(date, utc).substr(0, 3),\r\n    A: (date, utc) => DAYS[utc ? date.getUTCDay() : date.getDay()],\r\n    w: (date, utc) => `${utc ? date.getUTCDay() : date.getDay()}`,\r\n    H: (date, utc) => `0${utc ? date.getUTCHours() : date.getHours()}`.substr(-2),\r\n    I: (date, utc) => `0${(utc ? date.getUTCHours() : date.getHours()) % 12 || 12}`.substr(-2),\r\n    M: (date, utc) => `0${utc ? date.getUTCMinutes() : date.getMinutes()}`.substr(-2),\r\n    S: (date, utc) => `0${utc ? date.getUTCSeconds() : date.getSeconds()}`.substr(-2),\r\n    c: (date, utc) => date.toLocaleString(undefined, utc ? { timeZone: 'UTC' } : undefined),\r\n    x: (date, utc) => {\r\n        const m = DATE_FORMAT_HANDLERS.m(date, utc)\r\n        const d = DATE_FORMAT_HANDLERS.d(date, utc)\r\n        const y = DATE_FORMAT_HANDLERS.y(date, utc)\r\n        return `${m}/${d}/${y}`\r\n    },\r\n    X: (date, utc) => {\r\n        const h = DATE_FORMAT_HANDLERS.H(date, utc)\r\n        const m = DATE_FORMAT_HANDLERS.M(date, utc)\r\n        const s = DATE_FORMAT_HANDLERS.S(date, utc)\r\n        return `${h}:${m}:${s}`\r\n    },\r\n    p: (date, utc) => ((utc ? date.getUTCHours() : date.getHours()) < 12 ? 'AM' : 'PM'),\r\n    Z: (date, utc) => {\r\n        if (utc) return 'UTC'\r\n        const match = date.toString().match(/[A-Z][A-Z][A-Z]/)\r\n        return match ? match[0] : ''\r\n    }\r\n}\r\n\r\nfunction isDST(date: Date): boolean {\r\n    const year = date.getFullYear()\r\n    const jan = new Date(year, 0)\r\n\r\n    // ASSUMPTION: If the time offset of the date is the same as it would be in January of the same year, DST is not in effect.\r\n    return date.getTimezoneOffset() !== jan.getTimezoneOffset()\r\n}\r\n\r\nfunction getWeekOfYear(date: Date, firstDay: number, utc: boolean): string {\r\n    const dayOfYear = parseInt(DATE_FORMAT_HANDLERS.j(date, utc), 10)\r\n    const jan1 = new Date(date.getFullYear(), 0, 1, 12)\r\n    const offset = (8 - (utc ? jan1.getUTCDay() : jan1.getDay()) + firstDay) % 7\r\n\r\n    return `0${Math.floor((dayOfYear - offset) / 7) + 1}`.substr(-2)\r\n}\r\n\r\nfunction date(input = '%c', time?: number): string | Table {\r\n    const utc = input.substr(0, 1) === '!'\r\n    const string = utc ? input.substr(1) : input\r\n    const date = new Date()\r\n\r\n    if (time) {\r\n        date.setTime(time * 1000)\r\n    }\r\n\r\n    if (string === '*t') {\r\n        return new Table({\r\n            year: parseInt(DATE_FORMAT_HANDLERS.Y(date, utc), 10),\r\n            month: parseInt(DATE_FORMAT_HANDLERS.m(date, utc), 10),\r\n            day: parseInt(DATE_FORMAT_HANDLERS.d(date, utc), 10),\r\n            hour: parseInt(DATE_FORMAT_HANDLERS.H(date, utc), 10),\r\n            min: parseInt(DATE_FORMAT_HANDLERS.M(date, utc), 10),\r\n            sec: parseInt(DATE_FORMAT_HANDLERS.S(date, utc), 10),\r\n            wday: parseInt(DATE_FORMAT_HANDLERS.w(date, utc), 10) + 1,\r\n            yday: parseInt(DATE_FORMAT_HANDLERS.j(date, utc), 10),\r\n            isdst: isDST(date)\r\n        })\r\n    }\r\n\r\n    return string.replace(/%[%YybBmUWjdaAwHIMScxXpZ]/g, f => DATE_FORMAT_HANDLERS[f[1] as Format](date, utc))\r\n}\r\n\r\nfunction setlocale(locale = 'C'): string {\r\n    if (locale === 'C') return 'C'\r\n\r\n    // TODO: implement fully\r\n}\r\n\r\nfunction time(table?: Table): number {\r\n    let now = Math.round(Date.now() / 1000)\r\n    if (!table) return now\r\n\r\n    const year = table.rawget('year') as number\r\n    const month = table.rawget('month') as number\r\n    const day = table.rawget('day') as number\r\n    const hour = (table.rawget('hour') as number) || 12\r\n    const min = table.rawget('min') as number\r\n    const sec = table.rawget('sec') as number\r\n    // const isdst = table.rawget('isdst') as boolean\r\n\r\n    if (year) now += year * 31557600\r\n    if (month) now += month * 2629800\r\n    if (day) now += day * 86400\r\n    if (hour) now += hour * 3600\r\n    if (min) now += min * 60\r\n    if (sec) now += sec\r\n    return now\r\n}\r\n\r\nfunction difftime(t2: LuaType, t1: LuaType): number {\r\n    const T2 = coerceArgToNumber(t2, 'difftime', 1)\r\n    const T1 = coerceArgToNumber(t1, 'difftime', 2)\r\n    return T2 - T1\r\n}\r\n\r\nconst getLibOS = (cfg: Config): Table => {\r\n    function exit(code: LuaType): void {\r\n        if (!cfg.osExit) throw new LuaError('os.exit requires the config.osExit function')\r\n\r\n        let CODE = 0\r\n        if (typeof code === 'boolean' && code === false) CODE = 1\r\n        else if (typeof code === 'number') CODE = code\r\n\r\n        cfg.osExit(CODE)\r\n    }\r\n\r\n    return new Table({\r\n        date,\r\n        exit,\r\n        setlocale,\r\n        time,\r\n        difftime\r\n    })\r\n}\r\n\r\nexport { getLibOS }\r\n","import { Table } from '../Table'\r\nimport { LuaType, Config, coerceArgToString } from '../utils'\r\nimport { LuaError } from '../LuaError'\r\n\r\nconst getLibPackage = (\r\n    execModule: (content: string, moduleName: string) => LuaType,\r\n    cfg: Config\r\n): {\r\n    libPackage: Table\r\n    _require: (modname: LuaType) => LuaType\r\n} => {\r\n    const LUA_DIRSEP = '/'\r\n    const LUA_PATH_SEP = ';'\r\n    const LUA_PATH_MARK = '?'\r\n    const LUA_EXEC_DIR = '!'\r\n    const LUA_IGMARK = '-'\r\n\r\n    const LUA_PATH = cfg.LUA_PATH\r\n\r\n    const config = [LUA_DIRSEP, LUA_PATH_SEP, LUA_PATH_MARK, LUA_EXEC_DIR, LUA_IGMARK].join('\\n')\r\n\r\n    const loaded = new Table()\r\n    const preload = new Table()\r\n\r\n    const searchpath = (name: LuaType, path: LuaType, sep?: LuaType, rep?: LuaType): string | [undefined, string] => {\r\n        if (!cfg.fileExists) {\r\n            throw new LuaError('package.searchpath requires the config.fileExists function')\r\n        }\r\n\r\n        let NAME = coerceArgToString(name, 'searchpath', 1)\r\n        const PATH = coerceArgToString(path, 'searchpath', 2)\r\n        const SEP = sep === undefined ? '.' : coerceArgToString(sep, 'searchpath', 3)\r\n        const REP = rep === undefined ? '/' : coerceArgToString(rep, 'searchpath', 4)\r\n\r\n        NAME = NAME.replace(SEP, REP)\r\n\r\n        const paths = PATH.split(';').map(template => template.replace('?', NAME))\r\n\r\n        for (const path of paths) {\r\n            if (cfg.fileExists(path)) return path\r\n        }\r\n\r\n        return [undefined, `The following files don't exist: ${paths.join(' ')}`]\r\n    }\r\n\r\n    const searchers = new Table([\r\n        (moduleName: string): [undefined] | [() => LuaType] => {\r\n            const res = preload.rawget(moduleName)\r\n            if (res === undefined) {\r\n                return [undefined]\r\n            }\r\n            return [res as () => LuaType]\r\n        },\r\n        (moduleName: string): [undefined] | [string] | [(modname: string, path: string) => LuaType, string] => {\r\n            const res = searchpath(moduleName, libPackage.rawget('path'))\r\n            if (Array.isArray(res) && res[0] === undefined) {\r\n                return [res[1]]\r\n            }\r\n\r\n            if (!cfg.loadFile) {\r\n                throw new LuaError('package.searchers requires the config.loadFile function')\r\n            }\r\n\r\n            return [(moduleName: string, path: string) => execModule(cfg.loadFile(path), moduleName), res as string]\r\n        }\r\n    ])\r\n\r\n    function _require(modname: LuaType): LuaType {\r\n        const MODNAME = coerceArgToString(modname, 'require', 1)\r\n\r\n        const module = loaded.rawget(MODNAME)\r\n        if (module) return module\r\n\r\n        const searcherFns = searchers.numValues.filter(fn => !!fn) as Function[]\r\n\r\n        for (const searcher of searcherFns) {\r\n            const res = searcher(MODNAME)\r\n            if (res[0] !== undefined && typeof res[0] !== 'string') {\r\n                const loader = res[0]\r\n                const result = loader(MODNAME, res[1])\r\n                const module = result === undefined ? true : result\r\n                loaded.rawset(MODNAME, module)\r\n                return module\r\n            }\r\n        }\r\n\r\n        throw new LuaError(`Module '${MODNAME}' not found!`)\r\n    }\r\n\r\n    const libPackage = new Table({\r\n        path: LUA_PATH,\r\n        config,\r\n        loaded,\r\n        preload,\r\n        searchers,\r\n        searchpath\r\n    })\r\n\r\n    return { libPackage, _require }\r\n}\r\n\r\nexport { getLibPackage }\r\n","/* eslint-disable import/order */\r\n/* eslint-disable import/no-duplicates */\r\nimport { Scope } from './Scope'\r\nimport { createG } from './lib/globals'\r\nimport { operators } from './operators'\r\nimport { Table } from './Table'\r\nimport { LuaError } from './LuaError'\r\nimport { libMath } from './lib/math'\r\nimport { libTable } from './lib/table'\r\nimport { libString, metatable as stringMetatable } from './lib/string'\r\nimport { getLibOS } from './lib/os'\r\nimport { getLibPackage } from './lib/package'\r\nimport { LuaType, ensureArray, Config } from './utils'\r\nimport { parse as parseScript } from './parser'\r\n\r\ninterface Script {\r\n    exec: () => LuaType\r\n}\r\n\r\nconst call = (f: Function | Table, ...args: LuaType[]): LuaType[] => {\r\n    if (f instanceof Function) return ensureArray(f(...args))\r\n\r\n    const mm = f instanceof Table && f.getMetaMethod('__call')\r\n    if (mm) return ensureArray(mm(f, ...args))\r\n\r\n    throw new LuaError(`attempt to call an uncallable type`)\r\n}\r\n\r\nconst stringTable = new Table()\r\nstringTable.metatable = stringMetatable\r\n\r\nconst get = (t: Table | string, v: LuaType): LuaType => {\r\n    if (t instanceof Table) return t.get(v)\r\n    if (typeof t === 'string') return stringTable.get(v)\r\n\r\n    throw new LuaError(`no table or metatable found for given type`)\r\n}\r\n\r\nconst execChunk = (_G: Table, chunk: string, chunkName?: string): LuaType[] => {\r\n    const exec = new Function('__lua', chunk)\r\n    const globalScope = new Scope(_G.strValues).extend()\r\n    if (chunkName) globalScope.setVarargs([chunkName])\r\n    const res = exec({\r\n        globalScope,\r\n        ...operators,\r\n        Table,\r\n        call,\r\n        get\r\n    })\r\n    return res === undefined ? [undefined] : res\r\n}\r\n\r\nfunction createEnv(\r\n    config: Config = {}\r\n): {\r\n    parse: (script: string) => Script\r\n    parseFile: (path: string) => Script\r\n    loadLib: (name: string, value: Table) => void\r\n} {\r\n    const cfg: Config = {\r\n        LUA_PATH: './?.lua',\r\n        stdin: '',\r\n        stdout: console.log,\r\n        ...config\r\n    }\r\n\r\n    const _G = createG(cfg, execChunk)\r\n\r\n    const { libPackage, _require } = getLibPackage(\r\n        (content, moduleName) => execChunk(_G, parseScript(content), moduleName)[0],\r\n        cfg\r\n    )\r\n    const loaded = libPackage.get('loaded') as Table\r\n\r\n    const loadLib = (name: string, value: Table): void => {\r\n        _G.rawset(name, value)\r\n        loaded.rawset(name, value)\r\n    }\r\n\r\n    loadLib('_G', _G)\r\n    loadLib('package', libPackage)\r\n    loadLib('math', libMath)\r\n    loadLib('table', libTable)\r\n    loadLib('string', libString)\r\n    loadLib('os', getLibOS(cfg))\r\n\r\n    _G.rawset('require', _require)\r\n\r\n    const parse = (code: string): Script => {\r\n        const script = parseScript(code)\r\n        return {\r\n            exec: () => execChunk(_G, script)[0]\r\n        }\r\n    }\r\n\r\n    const parseFile = (filename: string): Script => {\r\n        if (!cfg.fileExists) throw new LuaError('parseFile requires the config.fileExists function')\r\n        if (!cfg.loadFile) throw new LuaError('parseFile requires the config.loadFile function')\r\n\r\n        if (!cfg.fileExists(filename)) throw new LuaError('file not found')\r\n\r\n        return parse(cfg.loadFile(filename))\r\n    }\r\n\r\n    return {\r\n        parse,\r\n        parseFile,\r\n        loadLib\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line import/first\r\nimport * as utils from './utils'\r\nexport { createEnv, Table, LuaError, utils }\r\n"],"names":["stringMetatable","len","sub","pow","type","concat","parseScript","parse"],"mappings":"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"}